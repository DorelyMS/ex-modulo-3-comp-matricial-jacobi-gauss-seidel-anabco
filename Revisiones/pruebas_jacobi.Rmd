---
title: "Revisión Método Jacobi"
author: ""
date: ""
#output: html_document
output:
  html_document:
    toc: true
    toc_float: true
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

La ejecución del presente markdown se realizó utilizando una MacBook Pro con un procesador 2.3 GHz Quad-Core Intel Core i5 y 8 GB de RAM.

```{r, echo=FALSE, warning=F}
library('matrixcalc')
library('pracma')
funcEsVectorValido <- function(mtrx, vct){

  # El vector b, debe tener la misma cantidad de filas que la matriz
  bool_VectorValido = FALSE
  if (nrow(mtrx) == length(vct)){
    bool_VectorValido = TRUE
  }

  bool_VectorValido

}

# Valida que sea cuadrada la matriz
funcEsMatrizCuadrada <- function(mtrx){

  # Si el número de filas es igual al número de columnas, es una matriz cuadrada
  if (nrow(mtrx)==ncol(mtrx)){
    bool_Valida <- TRUE
  }
  else{
    bool_Valida <- FALSE
  }

  bool_Valida

}

 # Busca algún cero en la diagonal principal
funcHayCeroEnDiagonal <- function(mtrx){

  bool_HayCero <- FALSE
  nbr_Filas <- nrow(mtrx)
  nbr_Cols <- ncol(mtrx)

  for (i in 1:nbr_Filas){
    for (j in 1:nbr_Cols){
      if ((i==j) && (mtrx[i,j]==0)){
        bool_HayCero <- TRUE
      }
    }
  }

  bool_HayCero

}

# Función que obtiene cada componente del vector
funcObtenerComponente <- function(i, n, mtrx_A, vct_X, vct_B){

  # Variable en la cual acumularemos el resutlado de la sumatoria
  nbr_Sumatoria = 0
  nbr_Final = 0

  # Variables con los términos agrupados de los elementos de la fórmula
  nbr_Termino1 = 0
  nbr_Termino2 = 0

  # Sumatoria de j a n para toda j != i
  for (j in 1:n){
    if (j != i ){

      # Operación de la sumatoria
      nbr_Termino1 = (-(mtrx_A[i,j] * vct_X[j]) / (mtrx_A[i,i]))

      # Acumulamos los valores
      nbr_Sumatoria = nbr_Sumatoria + nbr_Termino1

    }
  }

  # Terminada la sumatoria, se prepara un término extra
  nbr_Termino2 = (vct_B[i] / mtrx_A[i,i])

  # El resultado final, es lo acumulado de la sumatoria más el otro término
  nbr_Final = nbr_Sumatoria + nbr_Termino2

  # Regresamos el resultado
  nbr_Final

}

# Función que obtiene la aproximación de las iteraciones
funcObtenerVctRslt <- function(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo){

  # Inicializamos los vectores de control
  vct_X_Act <- vct_X0
  vct_X_Ant <- vct_X0

  # Los siguientes prints son para debuguear, más adelante se eliminarán
  print(paste0('Iteracion ', 0))
  print(vct_X_Act)

  # Máximo número de iteraciones
  for (it in 1:nbr_MaxIteraciones){

    print(paste0('Iteracion ', it))

    # Iteraciones para obtener cada componente del vector de resultados
    for (i in 1:n){

      # Si se pidió usar el método Jacobi
      if (str_Metodo=='J'){
        vct_X_Act[i]=funcObtenerComponente(i, n, mtrx_A, vct_X_Ant, vct_B)
      }

      # Si se pidió usar el método Gauss-Seidel
      if (str_Metodo=='GS'){
        vct_X_Act[i]=funcObtenerComponente(i, n, mtrx_A, vct_X_Act, vct_B)
      }

    }

    print(vct_X_Act)

    nbr_Numerador <- Norm(vct_X_Act - vct_X_Ant, p = Inf)
    nbr_Denominador <- Norm(vct_X_Act, p = Inf)

    print(paste0('nbr_Numerador: ', nbr_Numerador))
    print(paste0('nbr_Denominador: ', nbr_Denominador))

    nbr_Diff <-  nbr_Numerador / nbr_Denominador
    print(paste0('nbr_Diff: ',nbr_Diff))

    # Si se llega a una diferencia menor al threshold indicado, salimos del for
    if (nbr_Diff<nbr_Threshold){
      print('Se alcanza el threshold')
      break
    }

    # El vector resultado (k), lo usamos como vector anterior (k-1) para la sigueinte
    # iteraación
    vct_X_Ant <- vct_X_Act

  }

  if (it==nbr_MaxIteraciones){
    print('Se llega al tope de iteraciones')
  }

  # Devolvemos el último vector calculado
  vct_X_Act

}

funcInterCambiarFilasVct <- function(vctOrigen, nbr_FilaOrigen, nbr_FilaDestino){

  # Se guarda el valor destino
  nbr_ValorTmp <- vctOrigen[nbr_FilaDestino]

  # Se pone el valor origen hacia el valor destino
  vctOrigen[nbr_FilaDestino] <- vctOrigen[nbr_FilaOrigen]

  # Se recupera el valor destino original, y se pone en valor origen
  vctOrigen[nbr_FilaOrigen] <- nbr_ValorTmp

  # Se regresa el valor
  vctOrigen

}

funcInterCambiarFilasMtrx <- function(mtrx, nbr_FilaOrigen, nbr_FilaDestino, nbr_Cols){

  # Se guarda el valor destino
  vct_FilaTmp <- mtrx[nbr_FilaDestino,1:nbr_Cols]

  # Se pone el valor origen hacia el valor destino
  mtrx[nbr_FilaDestino,1:nbr_Cols] <- mtrx[nbr_FilaOrigen,1:nbr_Cols]

  # Se recupera el valor destino original, y se pone en valor origen
  mtrx[nbr_FilaOrigen,1:nbr_Cols] <- vct_FilaTmp

  # Se regresa el valor
  mtrx

}

funcOrdenarEcuaciones <- function(mtrx_A, vct_B){
  # Ordena las ecuaciones del sistema buscando que no quede ningún cero
  # sobre la diagonal principal (no hay garantía de que no quede algún
  # cero sobre la diagonal). Para saber qué fila tomar, se hace una búsqueda
  # sobre cada columna preguntando por la norma infinito de cada vector-columna.
  # Puesto que el sistema de ecuaciones consta tanto de variables como de
  # resultados, es necesario tambén el re-acomodo del vector de resultados.
  #
  # Parámetros
  # ----------
  # mtrx_A : matriz
  #    La matriz que se va a ordenar
  # vct_B : vector
  #    El vector que se va a ordenar.
  #
  # Regresa
  # -------
  # list
  #    Una lista que contiene la matriz a evaluar y el vector de resultados.
  #

  # Variables que se usan dentro de la funcion
  nbr_Filas <- nrow(mtrx_A)
  nbr_Cols <- ncol(mtrx_A)

  # Se barren todas las columnas (iterador j)
  for (j in 1:nbr_Cols){
    # print('Inicia iteracion')

    # Se saca el vector-columna que se usará esta iteración
    vct_Col = mtrx_A[1:nbr_Cols,j]

    # Mostramos el vector-columna con el que trabajaremos
    # print(vct_Col)

    # Se obtiene la norma infinita del vector-columna
    nbr_Norm = Norm(vct_Col, p = Inf)
    # print(nbr_Norm)

    # Se pregunta si el valor es único en el vector-columna
    vct_OrdDesc <- sort(vct_Col, decreasing = TRUE)
    # print(vct_OrdDesc)

    # Si sí es único:
    if (vct_OrdDesc[1] != vct_OrdDesc[2]){
      #print('Es unico')

      # Se obtiene el índice donde está ese valor
      nbr_Index <- match(nbr_Norm,vct_Col)
      # print(nbr_Index)

      # Si el índice es un NA
      if (is.na(nbr_Index)==TRUE){

        # Multiplicamos el valor de la norma infinito por -1
        nbr_Index <- match(nbr_Norm * -1,vct_Col)

      }

      # Para realizar el intercambio de filas, nuestra
      # fila origen será: nbr_Index, y la fila destino: j
      mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
      vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

      # print(mtrx_A)

    } else { # Si no es único:
      #print('Hay empate')

      vct_Bool1 <- (vct_Col==nbr_Norm)

      mtrx_Tmp <- mtrx_A[vct_Bool1,1:nbr_Cols]
      #print(mtrx_Tmp)

      # Barremos el resto de las columans para el desempate
      for (jj in (j+1):nbr_Cols){

        vct_ColDesempate <- mtrx_Tmp[,jj]
        # print(paste0('vct_ColDesempate: ', vct_ColDesempate))

        # Buscaremos el valor mínimo de la siguiente columna
        vct_OrdAsc <- sort(vct_ColDesempate)
        # print(vct_OrdAsc)

        # Si el  mínimo es único:
        if (vct_OrdAsc[1] != vct_OrdAsc[2]){

          # print('es unico')
          # Generamos el vector que nos ayudará a obtener las filas a desempatar
          vct_Bool2 <- (vct_ColDesempate == vct_OrdAsc[1])
          # print(vct_Bool2)

          vct_FilaDesempate <- mtrx_Tmp[vct_Bool2]

          # Ya que se tiene la fila mínima del empate, se obtiene su indice
          # en la matriz_A
          vct_Bool3 <- rowSums(mtrx_A == vct_FilaDesempate[col(mtrx_A)]) == ncol(mtrx_A)
          nbr_Index <- match(TRUE,vct_Bool3)

          # Para realizar el intercambio de filas, nuestra
          # fila origen será: nbr_Index, y la fila destino: j
          mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
          vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

          #print(mtrx_A)
          break

        }

      }

    }

  }

  # Regresamos en una lista, la matriz y vector ordenados
  list(matriz=mtrx_A,vector=vct_B)

}

funcResolverSE <- function(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo){

  if (str_Metodo == 'J' || str_Metodo == 'GS'){

    if (str_Metodo=='J'){
      print('Solucion mediante metodo de Jacobi')
    }
    if (str_Metodo=='GS'){
      print('Solucion mediante metodo de Gauss-Sidel')
    }

    print('Matriz A:')
    print(mtrx_A)

    print('Vector b:')
    print(vct_B)

    # Se aplican las validaciones de manera anidada
    if (funcEsVectorValido(mtrx_A, vct_B)){

      if (funcEsVectorValido(mtrx_A, vct_X0)){

        if (funcEsMatrizCuadrada(mtrx_A) == TRUE){

          # Obtenemos la n de la matriz
          n <- nrow(mtrx_A)

          if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

            # Se manda a llamar la función que obtendrá la aproximación
            vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo)

            # Se imprime el resultado
            print('Resultado final: ')
            print(vct_XRslt)

          } else {
            print('La matriz tiene algun cero en la diagonal, comienza ordenamiento')

            lt_Obj <- funcOrdenarEcuaciones(mtrx_A, vct_B)
            mtrx_A <- lt_Obj$matriz
            vct_B <- lt_Obj$vector

            print('Matriz ordenada:')
            print(mtrx_A)

            print('Vector ordenado:')
            print(vct_B)

            if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

              # Se manda a llamar la función que obtendrá la aproximación
              vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo)

              # Se imprime el resultado
              print('Resultado final: ')
              print(vct_XRslt)

            } else {
              print('Pese al reordenamiento, aun hay ceros en la diagonal')
            }

          }

        } else {
            print('La matriz no cumple con ser de dimensiones nxn')
        }
      } else {
        print('El vector de aproximaciones no es de las dimensiones esperadas')
      }
    } else {
      print('El vector de resultados no es de las dimensiones esperadas')
    }

  }else{
    print('El metodo especificado no es valido, favor de verificar')
  }
}

```

# Prueba con Ejemplo de Clase

La primera prueba es con la matriz ejemplo que se muestra en la nota de métodos iterativos [Jacobi y Gauss-Seidel](https://github.com/ITAM-DS/analisis-numerico-computo-cientifico/blob/master/temas/III.computo_matricial/3.3.e.Jacobi_Gauss-Seidel.ipynb) de nuestra materia de Métodos Numéricos y Optimización.

Declaramos un threshold pequeño para que el algoritmo pare a las 10 iteraciones y de esta forma se pueda comparar con el resultado obtenido en la nota de clase:


```{r, echo=FALSE }
mtrx_A <- matrix(c( 0,3,-1,8,
                   -1,11,-1,3,
                    2,-1,10,-1,
                    10,-1,2,0),
                 byrow = TRUE,
                 nrow=4,
                 ncol=4)

vct_B <- c(15, 25, -11, 6)

vct_X0 <- c(0,0,0,0)

nbr_MaxIteraciones <- 10

nbr_Threshold <- 10**(-10)

str_Metodo <- 'J'

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

El parámetro *str_Metodo* indica cuál método se ejecutará, Jacobi o Gauss-Seidel. Este documento se limita a la revisión del método de Jacobi, en otro documento se realizará la revisión del método Gauss-Seidel.

Ejecutamos nuestro método de Jacobi:

```{r, echo=TRUE}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)

```


En la décima iteración se llega al resultado de la nota, además la primera y segunda iteración cuadran con lo mostrado en la misma nota, lo cual indica que el algoritmo programado está realizando el método de forma adecuada.

Adicionalmente, reordena las ecuaciones para no tener ceros en la diagonal, eligiendo el elemento de máxima magnitud.


Contrastamos ahora esta solución con un método Jacobi ya implementado en la librería ```Rlinsolve```:

```{r, warning=FALSE, echo=FALSE, message = FALSE}
library(Rlinsolve)
```

```{r, echo=FALSE}
#ordenarla, pues de lo contrario lsolve.jacobi ya no cuadra
mtrx_A <- matrix(c( 10,-1,2,0,
                    -1,11,-1,3,
                    2,-1,10,-1,
                    0,3,-1,8),
                 byrow = TRUE,
                 nrow=4,
                 ncol=4)

vct_B <- c(6, 25, -11, 15)
```


```{r, warning=FALSE, message = FALSE}
sol.lsolve <- lsolve.jacobi(mtrx_A, vct_B, xinit = vct_X0, reltol = 1e-05, 
                            maxiter = 10, weight = 1, adjsym = FALSE, verbose = TRUE)

sol.lsolve$x
```

De esta forma verificamos nuevamente que la implementación es correcta para este ejemplo.


Ejecutamos el mismo ejemplo, con 100 iteraciones máximo y un threshold de $10^{-5}$

```{r, echo=FALSE }
mtrx_A <- matrix(c( 0,3,-1,8,
                   -1,11,-1,3,
                    2,-1,10,-1,
                    10,-1,2,0),
                 byrow = TRUE,
                 nrow=4,
                 ncol=4)

vct_B <- c(15, 25, -11, 6)

vct_X0 <- c(0,0,0,0)

nbr_MaxIteraciones <- 100

nbr_Threshold <- 10**(-5)

str_Metodo <- 'J'

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Obteniendo como resultado:

```{r, echo=FALSE}

funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)

```

Se detiene el algoritmo al alcanzar el threshold definido, obteniendo como resultado un vector muy similar al de 10 iteraciones.

Lo comparamos con la función ```lsolve.jacobi``` con los mismos parámetros:

```{r, echo=FALSE}

mtrx_A <- matrix(c( 10,-1,2,0,
                    -1,11,-1,3,
                    2,-1,10,-1,
                    0,3,-1,8),
                 byrow = TRUE,
                 nrow=4,
                 ncol=4)

vct_B <- c(6, 25, -11, 15)

vct_X0 <- c(0,0,0,0)
```


```{r, echo=TRUE, message=FALSE}

sol.lsolve <- lsolve.jacobi(mtrx_A, vct_B, xinit = vct_X0, reltol = 1e-05, 
                            maxiter = 100, weight = 1, adjsym = FALSE, verbose = TRUE)
sol.lsolve$x

```

Donde observamos que los resultados coinciden en aproximadamente 5 decimales, de hecho coincide el resultado de ```lsolve.jacobi``` con la iteración 14 de nuestro método, donde el cociente $\frac{||x^{(k)}-x^{(k-1)}||_\infty}{||x^{(k)}||_\infty}$ es igual a $1.33731330418549\times 10^{-5}$.



# Validaciones de Input

Ahora probamos que realice el resto de validaciones necesarias del método Jacobi (adicional a los ceros en diagonal verificadas en el ejemplo anterior).

### Matriz de $n \times n$

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(1,0,0,0,
                  0,1,2,1,
                  1,2,0,0,
                  1,1,1,0,
                  3,1,1,5),
                  nrow=5,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 6, 7)

vct_X0 <- c(0,0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)
```

Ahora colocamos más columnas que filas en la matriz $A$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(1,0,0,0,7,
                  0,1,2,1,0,
                  1,2,0,0,1,
                  1,1,1,0,3),
                  nrow=4,
                  ncol=5,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 6)

vct_X0 <- c(0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)
```


### Tamaño del vector $b$

Vector $b$ con menos elementos que el número de filas de $A$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11)

vct_X0 <- c(0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)
```

Dando ahora un vector $b$ con más elementos que el número de filas de la matriz $A$.

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 4, -8)

vct_X0 <- c(0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)
```

Damos ahora matrices en lugar de vectores en $b$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- matrix(c(1,2,0,7,
                  9,2,6,0,
                  2,5,0,1,
                  1,8,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)


vct_X0 <- c(0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)
```




### Tamaño del vector de aproximación inicial $x_0$

Vector de aproximación inicial $x_0$ con más elementos que el total de filas de $A$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 4)

vct_X0 <- c(0,0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)
```

Vector inicial $x_0$ con menos elementos que el total de filas de la matriz $A$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 4)

vct_X0 <- c(0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)
```



Damos ahora matrices en lugar de vectores en $x_0$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 4)

vct_X0 <- matrix(c(0,0,0,0,
                  0,0,0,0,
                  0,0,0,1,
                  0,0,0,0),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)
```




# Matrices Singulares

Veamos qué devuelve nuestro algoritmo al aplicarse en una matriz singular.

```{r, echo=F}

funcEsVectorValido <- function(mtrx, vct){
  # Valida si el vector (ya se de resultados o aproximaciones) cuenta
  # con la misma cantidad de filas que la matriz a evaluar.
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz a evaluar
  # vct : vector
  #    El vector cuyo # de filas se comparará contra las de la matriz a evaluar
  #
  # Regresa
  # -------
  # boolean
  #    Una bandera a manera de booleano indicando si la cantidad de filas del
  #    vector es igual o no a la cantidad de filas de la matriz a evaluar.
  #

  # El vector b, debe tener la misma cantidad de filas que la matriz
  bool_VectorValido = FALSE
  if (nrow(mtrx) == length(vct)){
    bool_VectorValido = TRUE
  }

  bool_VectorValido

}

# Valida que sea cuadrada la matriz
funcEsMatrizCuadrada <- function(mtrx){
  # Valida si la matriz es cuadrada (nxn)
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz a evaluar
  #
  # Regresa
  # -------
  # boolean
  #    Una bandera a manera de booleano indicando si la cantidad de filas y
  #    columnas de la matriz son iguales.
  #

  # Si el número de filas es igual al número de columnas, es una matriz cuadrada
  if (nrow(mtrx)==ncol(mtrx)){
    bool_Valida <- TRUE
  }
  else{
    bool_Valida <- FALSE
  }

  bool_Valida

}

 # Busca algún cero en la diagonal principal
funcHayCeroEnDiagonal <- function(mtrx){
  # Valida si se presenta alún cero en la diagonal de la matriz
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz a evaluar
  #
  # Regresa
  # -------
  # boolean
  #    Una bandera a manera de booleano indicando si se encontró un cero en
  #    la diagonal de la matriz.
  #

  bool_HayCero <- FALSE
  nbr_Filas <- nrow(mtrx)
  nbr_Cols <- ncol(mtrx)

  for (i in 1:nbr_Filas){
    for (j in 1:nbr_Cols){
      if ((i==j) && (mtrx[i,j]==0)){
        bool_HayCero <- TRUE
      }
    }
  }

  bool_HayCero

}

# Función que obtiene cada componente del vector
funcObtenerComponente <- function(i, n, mtrx_A, vct_X, vct_B){
  # Obtiene 1 solo componente del vector de aproximaciones
  #
  # Parámetros
  # ----------
  # i : número
  #    Indidce del componente (del vector de aproximaciones) que se quiere obtener
  # n : número
  #    Dimensión de filas o columnas de la matriz
  # mtrx_A: matriz
  #    La matriz que se está evaluando
  # vct_X : vector
  #    Vector de aproximaciones
  # vct_B : vector
  #    Vector de resultados del sistema de ecuaciones
  #
  # Regresa
  # -------
  # número
  #    El valor del componente indicado para el vector de aproximaciones
  #

  # Variable en la cual acumularemos el resutlado de la sumatoria
  nbr_Sumatoria = 0
  nbr_Final = 0

  # Variables con los términos agrupados de los elementos de la fórmula
  nbr_Termino1 = 0
  nbr_Termino2 = 0

  # Sumatoria de j a n para toda j != i
  for (j in 1:n){
    if (j != i ){

      # Operación de la sumatoria
      nbr_Termino1 = (-(mtrx_A[i,j] * vct_X[j]) / (mtrx_A[i,i]))

      # Acumulamos los valores
      nbr_Sumatoria = nbr_Sumatoria + nbr_Termino1

    }
  }

  # Terminada la sumatoria, se prepara un término extra
  nbr_Termino2 = (vct_B[i] / mtrx_A[i,i])

  # El resultado final, es lo acumulado de la sumatoria más el otro término
  nbr_Final = nbr_Sumatoria + nbr_Termino2

  # Regresamos el resultado
  nbr_Final

}

# Función que obtiene la aproximación de las iteraciones
funcObtenerVctRslt <- function(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo){
  # Mediante un proceso de iteraciones, actualiza el vector de aproximaciones
  # vct_X0 para lograr la igualdad: mtrx_A * vct_X0 = vct_B
  # El proceso de iteraciones está sujeto a que se cumpla alguna de las
  # siguientes 2 condiciones:
  #   1: Alcanzar el máximo número de iteraciones (especificado en el parámetro
  #     nbr_MaxIteraciones)
  #   2: Lograr llegar a un diferencia entre iteraciones menor al threshold
  #     que se especifica en el parámetro nbr_Threshold.
  # En cuanto se cumpla alguna de dichas condiciones, termina el proceso de
  # iteraciones.
  # Adicionalmente, hay 2 maneras de calcular el vector de resultados, mediante
  # el método Jacobi o Gauss-Seidel. La manera de especificar qué método se
  # quiere emplear es con el parámetro: str_Metodo que se emplea de la
  # siguiente manera:
  # Si el valor de str_Metodo es 'J', se emplea el método Jacobi
  # Si el valor de str_Metodo es 'GS', se emplea el método Gauss-Seidel
  #
  # Parámetros
  # ----------
  # nbr_MaxIteraciones : número
  #    Máximo número de iteraciones a alcanzar
  # n : Número
  #    Dimensión de filas o columnas de la matriz
  # mtrx_A : matriz
  #    Matriz a evaluar
  # vct_B : vector
  #    Vector de resultados del sistema de ecuaciones
  # vct_X0 : vector
  #    Vector de aproximaciones
  # nbr_Threshold : número
  #    Diferencia mínima a la que se quiere llegar entre iteraciones para
  #    considerar que el método ha convergido
  # str_Metodo : cadena
  #    Cadena mediante la cual se especifica el método que se empleará para
  #    actualizar el vector de aproximaciones.
  #
  # Regresa
  # -------
  # vector
  #    El vector de aproximaciones actualizado luego del proceso de iteraciones
  #

  # Inicializamos los vectores de control
  vct_X_Act <- vct_X0
  vct_X_Ant <- vct_X0

  # Los siguientes prints son para debuguear, más adelante se eliminarán
  print(paste0('Iteracion ', 0))
  print(vct_X_Act)

  # Máximo número de iteraciones
  for (it in 1:nbr_MaxIteraciones){

    print(paste0('Iteracion ', it))

    # Iteraciones para obtener cada componente del vector de resultados
    for (i in 1:n){

      # Si se pidió usar el método Jacobi
      if (str_Metodo=='J'){
        vct_X_Act[i]=funcObtenerComponente(i, n, mtrx_A, vct_X_Ant, vct_B)
      }

      # Si se pidió usar el método Gauss-Seidel
      if (str_Metodo=='GS'){
        vct_X_Act[i]=funcObtenerComponente(i, n, mtrx_A, vct_X_Act, vct_B)
      }

    }

    print(vct_X_Act)

    nbr_Numerador <- Norm(vct_X_Act - vct_X_Ant, p = Inf)
    nbr_Denominador <- Norm(vct_X_Act, p = Inf)

    print(paste0('nbr_Numerador: ', nbr_Numerador))
    print(paste0('nbr_Denominador: ', nbr_Denominador))

    nbr_Diff <-  nbr_Numerador / nbr_Denominador
    print(paste0('nbr_Diff: ',nbr_Diff))

    # Si se empiezan a obtener valores NaN, significa que no hay solución
    if (is.na(nbr_Diff)){
      print('No hay convergencia')
      vct_X_Act <- rep(NA, size(vct_X0)[2])
      break
    }

    # Si se llega a una diferencia menor al threshold indicado, salimos del for
    if (nbr_Diff<nbr_Threshold){
      print('Se alcanza el threshold')
      break
    }

    # El vector resultado (k), lo usamos como vector anterior (k-1) para la sigueinte
    # iteraación
    vct_X_Ant <- vct_X_Act

  }

  if (it==nbr_MaxIteraciones){
    print('Se llega al tope de iteraciones')
  }

  # Devolvemos el último vector calculado
  vct_X_Act

}

funcInterCambiarFilasVct <- function(vctOrigen, nbr_FilaOrigen, nbr_FilaDestino){
  # Intercambia las filas de un vector
  #
  # Parámetros
  # ----------
  # mtrx_A : vector
  #    El vector donde se realizará el intercambio de filas
  # nbr_FilaOrigen : número
  #    Índice de la fila origen que se moverá a la fila destino
  # nbr_FilaDestino : número
  #    Índice de la fila destino que se moverá a la fila origen
  #
  # Regresa
  # -------
  # vector
  #    El vector con los valores intercambiados
  #

  # Se guarda el valor destino
  nbr_ValorTmp <- vctOrigen[nbr_FilaDestino]

  # Se pone el valor origen hacia el valor destino
  vctOrigen[nbr_FilaDestino] <- vctOrigen[nbr_FilaOrigen]

  # Se recupera el valor destino original, y se pone en valor origen
  vctOrigen[nbr_FilaOrigen] <- nbr_ValorTmp

  # Se regresa el valor
  vctOrigen

}

funcInterCambiarFilasMtrx <- function(mtrx, nbr_FilaOrigen, nbr_FilaDestino, nbr_Cols){
  # Intercambia las filas de una matriz
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz donde se realizará el intercambio de filas
  # nbr_FilaOrigen : número
  #    Índice de la fila origen que se moverá a la fila destino
  # nbr_FilaDestino : número
  #    Índice de la fila destino que se moverá a la fila origen
  #
  # Regresa
  # -------
  # matriz
  #    La matriz con los valores intercambiados
  #

  # Se guarda el valor destino
  vct_FilaTmp <- mtrx[nbr_FilaDestino,1:nbr_Cols]

  # Se pone el valor origen hacia el valor destino
  mtrx[nbr_FilaDestino,1:nbr_Cols] <- mtrx[nbr_FilaOrigen,1:nbr_Cols]

  # Se recupera el valor destino original, y se pone en valor origen
  mtrx[nbr_FilaOrigen,1:nbr_Cols] <- vct_FilaTmp

  # Se regresa el valor
  mtrx

}

funcOrdenarEcuaciones <- function(mtrx_A, vct_B){
  # Ordena las ecuaciones del sistema buscando que no quede ningún cero
  # sobre la diagonal principal (no hay garantía de que no quede algún
  # cero sobre la diagonal). Para saber qué fila tomar, se hace una búsqueda
  # sobre cada columna preguntando por la norma infinito de cada vector-columna.
  # Puesto que el sistema de ecuaciones consta tanto de variables como de
  # resultados, es necesario tambén el re-acomodo del vector de resultados.
  #
  # Parámetros
  # ----------
  # mtrx_A : matriz
  #    La matriz que se va a ordenar
  # vct_B : vector
  #    El vector que se va a ordenar.
  #
  # Regresa
  # -------
  # list
  #    Una lista que contiene la matriz a evaluar y el vector de resultados.
  #

  # Variables que se usan dentro de la funcion
  nbr_Filas <- nrow(mtrx_A)
  nbr_Cols <- ncol(mtrx_A)

  # Se barren todas las columnas (iterador j)
  for (j in 1:nbr_Cols){
    # print('Inicia iteracion')

    # Se saca el vector-columna que se usará esta iteración
    vct_Col = mtrx_A[1:nbr_Cols,j]

    # Mostramos el vector-columna con el que trabajaremos
    # print(vct_Col)

    # Se obtiene la norma infinita del vector-columna
    nbr_Norm = Norm(vct_Col, p = Inf)
    # print(nbr_Norm)

    # Se pregunta si el valor es único en el vector-columna
    vct_OrdDesc <- sort(vct_Col, decreasing = TRUE)
    # print(vct_OrdDesc)

    # Si sí es único:
    if (vct_OrdDesc[1] != vct_OrdDesc[2]){
      #print('Es unico')

      # Se obtiene el índice donde está ese valor
      nbr_Index <- match(nbr_Norm,vct_Col)
      # print(nbr_Index)

      # Si el índice es un NA
      if (is.na(nbr_Index)==TRUE){

        # Multiplicamos el valor de la norma infinito por -1
        nbr_Index <- match(nbr_Norm * -1,vct_Col)

      }

      # Para realizar el intercambio de filas, nuestra
      # fila origen será: nbr_Index, y la fila destino: j
      mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
      vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

      # print(mtrx_A)

    } else { # Si no es único:
      #print('Hay empate')

      vct_Bool1 <- (vct_Col==nbr_Norm)

      mtrx_Tmp <- mtrx_A[vct_Bool1,1:nbr_Cols]
      #print(mtrx_Tmp)

      # Barremos el resto de las columans para el desempate
      for (jj in (j+1):nbr_Cols){

        vct_ColDesempate <- mtrx_Tmp[,jj]
        # print(paste0('vct_ColDesempate: ', vct_ColDesempate))

        # Buscaremos el valor mínimo de la siguiente columna
        vct_OrdAsc <- sort(vct_ColDesempate)
        # print(vct_OrdAsc)

        # Si el  mínimo es único:
        if (vct_OrdAsc[1] != vct_OrdAsc[2]){

          # print('es unico')
          # Generamos el vector que nos ayudará a obtener las filas a desempatar
          vct_Bool2 <- (vct_ColDesempate == vct_OrdAsc[1])
          # print(vct_Bool2)

          vct_FilaDesempate <- mtrx_Tmp[vct_Bool2]

          # Ya que se tiene la fila mínima del empate, se obtiene su indice
          # en la matriz_A
          vct_Bool3 <- rowSums(mtrx_A == vct_FilaDesempate[col(mtrx_A)]) == ncol(mtrx_A)
          nbr_Index <- match(TRUE,vct_Bool3)

          # Para realizar el intercambio de filas, nuestra
          # fila origen será: nbr_Index, y la fila destino: j
          mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
          vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

          #print(mtrx_A)
          break

        }

      }

    }

  }

  # Regresamos en una lista, la matriz y vector ordenados
  list(matriz=mtrx_A,vector=vct_B)

}

funcResolverSE <- function(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo){
  # Resuleve un sistema de ecuaciones lineales mediante el método de Jacobi
  # o de Gauss-Seidel. El sistema de ecuaciones sólo se procesará si pasa
  # todas las validaciones requeridas.
  #
  # Parámetros
  # -------
  # mtrx_A : matriz
  #    Matriz a evaluar
  # vct_B : vector
  #    Vector de resultados del sistema de ecuaciones
  # vct_X0 : vector
  #    Vector de aproximaciones
  # nbr_MaxIteraciones : número
  #    Máximo número de iteraciones a alcanzar
  # nbr_Threshold : número
  #    Diferencia mínima a la que se quiere llegar entre iteraciones para
  #    considerar que el método ha convergido
  # str_Metodo : cadena
  #    Cadena mediante la cual se especifica el método que se empleará para
  #    actualizar el vector de aproximaciones.
  #
  # Regresa
  # -------
  # vector
  #    El vector de aproximaciones luego del proceso de iteraciones

  # Se agrega condicón para validar que la matriz no sea singular

  # Se inicializa el vector de resultados
  vct_XRslt <- rep(NA, size(vct_X0)[2])

  if(!is.singular.matrix(mtrx_A)){

    if (str_Metodo == 'J' || str_Metodo == 'GS'){

      if (str_Metodo=='J'){
        print('Solucion mediante metodo de Jacobi')
      }
      if (str_Metodo=='GS'){
        print('Solucion mediante metodo de Gauss-Seidel')
      }

      print('Matriz A:')
      print(mtrx_A)

      print('Vector b:')
      print(vct_B)

      # Se aplican las validaciones de manera anidada
      if (funcEsVectorValido(mtrx_A, vct_B)){

        if (funcEsVectorValido(mtrx_A, vct_X0)){

          if (funcEsMatrizCuadrada(mtrx_A) == TRUE){

            # Obtenemos la n de la matriz
            n <- nrow(mtrx_A)

            if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

              # Se manda a llamar la función que obtendrá la aproximación
              vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo)

              # Se imprime el resultado
              print('Resultado final: ')
              print(vct_XRslt)

            } else {
              print('La matriz tiene algun cero en la diagonal, comienza ordenamiento')

              lt_Obj <- funcOrdenarEcuaciones(mtrx_A, vct_B)
              mtrx_A <- lt_Obj$matriz
              vct_B <- lt_Obj$vector

              print('Matriz ordenada:')
              print(mtrx_A)

              print('Vector ordenado:')
              print(vct_B)

              if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

                # Se manda a llamar la función que obtendrá la aproximación
                vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo)

                # Se imprime el resultado
                print('Resultado final: ')
                print(vct_XRslt)

              } else {
                print('Pese al reordenamiento, aun hay ceros en la diagonal')
              }

            }

          } else {
              print('La matriz no cumple con ser de dimensiones nxn')
          }
        } else {
          print('El vector de aproximaciones no es de las dimensiones esperadas')
        }
      } else {
        print('El vector de resultados no es de las dimensiones esperadas')
      }

    }else{
      print("El metodo especificado no es valido, se espera 'GS' para Gauss-Seidel o 'J' para Jacobi")
    }
  }else{
    print('La matriz es singular, por lo tanto no hay solución al sistema y el método se detiene')
  }

  # Se devuelve el vector de resultados
  vct_XRslt

}
```


Definimos nuestro sistema:

```{r echo=FALSE}

mtrx_A <- ones(2)

vct_B <- c(15, 25)

# Vector de aproximación inicial
vct_X0 <- c(0,0)

# Máximo número de iteraciones permitido
nbr_MaxIteraciones <- 50

# Threshold que se busca alcanzar
nbr_Threshold <- 10**(-5)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold a alcanzar:')
print(nbr_Threshold)


```
Verificamos que la matriz propuesta es singular, y por lo tanto no tiene solución:

```{r}
is.singular.matrix(mtrx_A)
```

Aplicamos el método implementado:
```{r}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)

```



# Matrices Dominantes Estrictas en la Diagonal por Renglones

Una [matriz dominante estricta en la diagonal por renglones](https://github.com/ITAM-DS/analisis-numerico-computo-cientifico/blob/master/temas/III.computo_matricial/3.3.e.Jacobi_Gauss-Seidel.ipynb) es aquélla que cumple:

$\mid a_{ij} \mid \gt \sum_{\overset{j=1}{j\neq i}}^n \mid a_{ij} \mid$ para toda $i$, donde $a_{ij}$ es el elemento del renglón $i$ y columna $j$ de $A$.


Realizaremos pruebas con estas matrices, pues como se menciona en [la nota de clase](https://github.com/ITAM-DS/analisis-numerico-computo-cientifico/blob/master/temas/III.computo_matricial/3.3.e.Jacobi_Gauss-Seidel.ipynb), existe un teorema que garantiza la convergencia del método Jacobi si la matriz A es dominante estricta en la diagonal por renglones.

Probamos con el ejemplo más sencillo de estas matrices, donde $A$ es la matriz identidad:

```{r, echo=F}

mtrx_A <- diag(10)


vct_B <- c(-12,
           -8,
           9,
           -17,
           19,
           20,
           19,
           19,
           29,
           -5)


vct_X0 <- c(0,0,0,0,0,0,0,0,0,0)

nbr_MaxIteraciones <- 100

nbr_Threshold <- 10**(-5)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)

```

Obteniendo como resultado el vector $b$:

```{r, echo_FALSE}

funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)


```

En este punto, es importante aclarar que la función ```lsolve.jacobi``` de la librería ```Rlinsolve``` para converger, requiere tener los renglones ordenados, esta función no los ordena. Por ejemplo, en el caso de la matriz identidad, si movemos los renglones de forma aleatoria:

```{r, echo=F}

M <- diag(10)
nr<-dim(M)[1]
M<-M[sample.int(nr),]
b2 <- c(100*rnorm(10))
x20 <- c(rep(0,10))
M

```


```{r, message=F}

sol.lsolve <- lsolve.jacobi(M, b2, xinit = x20, reltol = 1e-05, 
                            maxiter = 100, weight = 1, adjsym = FALSE, verbose = TRUE)
sol.lsolve$x
sol.lsolve$iter
```

No obtiene la solución a pesar de tratarse simplemente de la matriz identidad con los renglones intercambiados.

Mientras que nuestro método ordena los renglones y obtiene la solución:

```{r}
funcResolverSE(M, b2, x20, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)

```
Por lo tanto, en las pruebas de este documento, para contrastar contra ```lsolve.jacobi``` le damos como input la matriz ordenada mediante nuestra función  *funcOrdenarEcuaciones*.


Probamos ahora una matriz de $10 \times 10$ estrictamente diagonal positiva diferente a la identidad:

```{r, echo=F}

mtrx_A <- matrix(c( 300,19,15,-20,-29,29,-15,-28,-9,-6,
                    -1,-150,-14,0,-7,14,11,-6,6,10,
                    13,3,-310,9,-8,7,-6,8,20,-22,
                    3,-2,-15,260,2,-12,18,-10,-17,25,
                    -23,-29,6,9,320,-4,4,-13,13,8,
                    -4,15,9,12,21,220,-14,1,18,-1,
                    11,-11,8,28,13,27,-330,18,24,13,
                    17,-17,-10,-7,11,22,21,240,12,-21,
                    9,-22,-9,-16,4,-20,28,16,300,17,
                    16,20,13,15,-26,8,24,5,-27,280),
                 byrow = TRUE,
                 nrow=10,
                 ncol=10)

vct_B <- c(-12,
           -8,
           9,
           -17,
           19,
           20,
           19,
           19,
           29,
           -5)


vct_X0 <- c(0,0,0,0,0,0,0,0,0,0)

nbr_MaxIteraciones <- 100

nbr_Threshold <- 10**(-5)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

El algoritmo devuelve:

```{r}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)


```

Se detiene en la iteración 8 al llegar al threshold, pues el método converge.

La función ```lsolve.jacobi``` devuelve un resultado muy similar, con aproximadamente 6 decimales iguales al resultado de nuestro algoritmo:

```{r, echo=F, message=F}

sol.lsolve <- lsolve.jacobi(mtrx_A, vct_B, xinit = vct_X0, reltol = 1e-05, 
                            maxiter = 100, weight = 1, adjsym = FALSE, verbose = TRUE)

```


```{r, echo=T, message=F}

sol.lsolve$x
sol.lsolve$iter

```

De hecho este resultado es el mismo que se obtiene en la iteración 7 de nuestro algoritmo.

Verificamos el número de condición de la matriz:
```{r}
cond(mtrx_A)
```

Resulta ser una matriz bien condicionada, pues su número de condición es pequeño (cercano a 1).

# Matrices "Grandes"

Probamos ahora con una matriz de mayor dimensión, de $10^2 \times 10^2$, en este documento nos referimos a matriz "grande" porque será la mayor dimensión con la cual evaluaremos el algoritmo implementado.


```{r, echo=F}
mat_A_10_2 <-read.csv("matriz_ej_ordenar.csv")
mat_A_10_2 <- mat_A_10_2[,2:101]
colnames(mat_A_10_2) <- NULL
mat_A_10_2 <- as.matrix(mat_A_10_2)
dimnames(mat_A_10_2)<-NULL

```

Definimos el resto de parámetros necesarios:

```{r echo=FALSE}
set.seed(1604)
vct_B_10_2 <- (sample.int(1000,size=100,replace=TRUE))


vct_x0_10_2 <- rep(0,100)

nbr_MaxIteraciones <- 30

nbr_Threshold <- 10**(-5)

print('Dimensiones matriz A:')
print(dim(mat_A_10_2))

print('Dimensiones vector b:')
print(size(vct_B_10_2))

print('Dimensiones punto inicial:')
print(size(vct_x0_10_2))

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Al intentar resolver el sistema con nuestro algoritmo se obtiene:

```{r}
funcResolverSE(mat_A_10_2, vct_B_10_2, vct_x0_10_2, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)
```

Llegando al tope de iteraciones.

Intentemos resolver el sistema mediante la librería ```Rlinsolve```, para ello, necesitamos primero reordenar la matriz. Lo hacemos con una de las funciones propuestas en nuestra implementación:

```{r}
lt_Obj <- funcOrdenarEcuaciones(mat_A_10_2, vct_B_10_2)
mat_10_2 <- lt_Obj$matriz
vct_B <- lt_Obj$vector
```

Ahora probamos el método  ```lsolve.jacobi``` :

```{r message=FALSE}

sol.lsolve <- lsolve.jacobi(mat_10_2, vct_B, xinit = vct_x0_10_2, reltol = nbr_Threshold,  maxiter = nbr_MaxIteraciones, adjsym = FALSE, verbose = TRUE)

sol.lsolve$x

```

El algoritmo llega de igual forma al tope de iteraciones:

```{r echo=F, message=FALSE}
sol.lsolve$iter
```

Verificamos el número de condición de la matriz:
```{r}
cond(mat_10_2)
```

Resultando ser un número grande, casi de $10^3$, por lo tanto no podemos confiar en la solución. Además al no ser una matriz dominante estricta en la diagonal por renglones, no hay garantía de convergencia del método de Jacobi.

Probamos ahora con una matriz bien condicionada, de las misma dimensiones $10^2 \times 10^2$.



```{r, echo=F}

set.seed(123)
mat <- matrix(data = 100*rnorm(10000), nrow = 100, ncol = 100)
mode(mat) <- "integer"
mode(mat) <- "numeric"

b <- c(100*rnorm(100))

mode(b) <- "integer"
mode(b) <- "numeric"

x0 <- c(rep(0,100))

nbr_MaxIteraciones <- 100
nbr_Threshold <- 10**(-5)

mat2 <- mat
diag(mat2) <- 5000+diag(mat)

print('Dimensiones matriz A:')
print(dim(mat2))

print('Dimensiones vector b:')
print(size(b))

print('Dimensiones punto inicial:')
print(size(x0))

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Su número de condición es 
```{r}
cond(mat2)
```

Al resolver el sistema con nuestro algoritmo obtenemos:
```{r}
funcResolverSE(mat2, b, x0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)

```

Nuestro método converge en la iteración 9.

Lo resolvemos con la función ```lsolve.jacobi```:
```{r, message=F}

sol.lsolve <- lsolve.jacobi(mat2, b, xinit = x0, reltol = 1e-05, 
                            maxiter = 100, weight = 1, adjsym = FALSE, verbose = TRUE)
sol.lsolve$x
sol.lsolve$iter
```

Se obtiene un resultado muy similar al de nuestro algoritmo, con aproximadamente 6 decimales iguales.

# Matrices Sparse

Probamos ahora nuestro algoritmo con matrices sparse (ralas).

```{r, echo=F, message = F}

funcEsVectorValido <- function(mtrx, vct){
  # Valida si el vector (ya se de resultados o aproximaciones) cuenta
  # con la misma cantidad de filas que la matriz a evaluar.
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz a evaluar
  # vct : vector
  #    El vector cuyo # de filas se comparará contra las de la matriz a evaluar
  #
  # Regresa
  # -------
  # boolean
  #    Una bandera a manera de booleano indicando si la cantidad de filas del
  #    vector es igual o no a la cantidad de filas de la matriz a evaluar.
  #

  # El vector b, debe tener la misma cantidad de filas que la matriz
  bool_VectorValido = FALSE
  if (nrow(mtrx) == length(vct)){
    bool_VectorValido = TRUE
  }

  bool_VectorValido

}

# Valida que sea cuadrada la matriz
funcEsMatrizCuadrada <- function(mtrx){
  # Valida si la matriz es cuadrada (nxn)
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz a evaluar
  #
  # Regresa
  # -------
  # boolean
  #    Una bandera a manera de booleano indicando si la cantidad de filas y
  #    columnas de la matriz son iguales.
  #

  # Si el número de filas es igual al número de columnas, es una matriz cuadrada
  if (nrow(mtrx)==ncol(mtrx)){
    bool_Valida <- TRUE
  }
  else{
    bool_Valida <- FALSE
  }

  bool_Valida

}

 # Busca algún cero en la diagonal principal
funcHayCeroEnDiagonal <- function(mtrx){
  # Valida si se presenta alún cero en la diagonal de la matriz
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz a evaluar
  #
  # Regresa
  # -------
  # boolean
  #    Una bandera a manera de booleano indicando si se encontró un cero en
  #    la diagonal de la matriz.
  #

  bool_HayCero <- FALSE
  nbr_Filas <- nrow(mtrx)
  nbr_Cols <- ncol(mtrx)

  for (i in 1:nbr_Filas){
    for (j in 1:nbr_Cols){
      if ((i==j) && (mtrx[i,j]==0)){
        bool_HayCero <- TRUE
      }
    }
  }

  bool_HayCero

}

# Función que obtiene cada componente del vector
funcObtenerComponente <- function(i, n, mtrx_A, vct_X, vct_B){
  # Obtiene 1 solo componente del vector de aproximaciones
  #
  # Parámetros
  # ----------
  # i : número
  #    Indidce del componente (del vector de aproximaciones) que se quiere obtener
  # n : número
  #    Dimensión de filas o columnas de la matriz
  # mtrx_A: matriz
  #    La matriz que se está evaluando
  # vct_X : vector
  #    Vector de aproximaciones
  # vct_B : vector
  #    Vector de resultados del sistema de ecuaciones
  #
  # Regresa
  # -------
  # número
  #    El valor del componente indicado para el vector de aproximaciones
  #

  # Variable en la cual acumularemos el resutlado de la sumatoria
  nbr_Sumatoria = 0
  nbr_Final = 0

  # Variables con los términos agrupados de los elementos de la fórmula
  nbr_Termino1 = 0
  nbr_Termino2 = 0

  # Sumatoria de j a n para toda j != i
  for (j in 1:n){
    if (j != i ){

      # Operación de la sumatoria
      nbr_Termino1 = (-(mtrx_A[i,j] * vct_X[j]) / (mtrx_A[i,i]))

      # Acumulamos los valores
      nbr_Sumatoria = nbr_Sumatoria + nbr_Termino1

    }
  }

  # Terminada la sumatoria, se prepara un término extra
  nbr_Termino2 = (vct_B[i] / mtrx_A[i,i])

  # El resultado final, es lo acumulado de la sumatoria más el otro término
  nbr_Final = nbr_Sumatoria + nbr_Termino2

  # Regresamos el resultado
  nbr_Final

}

# Función que obtiene la aproximación de las iteraciones
funcObtenerVctRslt <- function(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo){
  # Mediante un proceso de iteraciones, actualiza el vector de aproximaciones
  # vct_X0 para lograr la igualdad: mtrx_A * vct_X0 = vct_B
  # El proceso de iteraciones está sujeto a que se cumpla alguna de las
  # siguientes 2 condiciones:
  #   1: Alcanzar el máximo número de iteraciones (especificado en el parámetro
  #     nbr_MaxIteraciones)
  #   2: Lograr llegar a un diferencia entre iteraciones menor al threshold
  #     que se especifica en el parámetro nbr_Threshold.
  # En cuanto se cumpla alguna de dichas condiciones, termina el proceso de
  # iteraciones.
  # Adicionalmente, hay 2 maneras de calcular el vector de resultados, mediante
  # el método Jacobi o Gauss-Seidel. La manera de especificar qué método se
  # quiere emplear es con el parámetro: str_Metodo que se emplea de la
  # siguiente manera:
  # Si el valor de str_Metodo es 'J', se emplea el método Jacobi
  # Si el valor de str_Metodo es 'GS', se emplea el método Gauss-Seidel
  #
  # Parámetros
  # ----------
  # nbr_MaxIteraciones : número
  #    Máximo número de iteraciones a alcanzar
  # n : Número
  #    Dimensión de filas o columnas de la matriz
  # mtrx_A : matriz
  #    Matriz a evaluar
  # vct_B : vector
  #    Vector de resultados del sistema de ecuaciones
  # vct_X0 : vector
  #    Vector de aproximaciones
  # nbr_Threshold : número
  #    Diferencia mínima a la que se quiere llegar entre iteraciones para
  #    considerar que el método ha convergido
  # str_Metodo : cadena
  #    Cadena mediante la cual se especifica el método que se empleará para
  #    actualizar el vector de aproximaciones.
  #
  # Regresa
  # -------
  # vector
  #    El vector de aproximaciones actualizado luego del proceso de iteraciones
  #

  # Inicializamos los vectores de control
  vct_X_Act <- vct_X0
  vct_X_Ant <- vct_X0

  # Los siguientes prints son para debuguear, más adelante se eliminarán
  print(paste0('Iteracion ', 0))
  print(vct_X_Act)

  # Máximo número de iteraciones
  for (it in 1:nbr_MaxIteraciones){

    print(paste0('Iteracion ', it))

    # Iteraciones para obtener cada componente del vector de resultados
    for (i in 1:n){

      # Si se pidió usar el método Jacobi
      if (str_Metodo=='J'){
        vct_X_Act[i]=funcObtenerComponente(i, n, mtrx_A, vct_X_Ant, vct_B)
      }

      # Si se pidió usar el método Gauss-Seidel
      if (str_Metodo=='GS'){
        vct_X_Act[i]=funcObtenerComponente(i, n, mtrx_A, vct_X_Act, vct_B)
      }

    }

    print(vct_X_Act)

    nbr_Numerador <- Norm(vct_X_Act - vct_X_Ant, p = Inf)
    nbr_Denominador <- Norm(vct_X_Act, p = Inf)

    print(paste0('nbr_Numerador: ', nbr_Numerador))
    print(paste0('nbr_Denominador: ', nbr_Denominador))

    nbr_Diff <-  nbr_Numerador / nbr_Denominador
    print(paste0('nbr_Diff: ',nbr_Diff))

    # Si se empiezan a obtener valores NaN, significa que no hay solución
    if (is.na(nbr_Diff)){
      print('No hay convergencia')
      vct_X_Act <- rep(NA, size(vct_X0)[2])
      break
    }

    # Si se llega a una diferencia menor al threshold indicado, salimos del for
    if (nbr_Diff<nbr_Threshold){
      print('Se alcanza el threshold')
      break
    }

    # El vector resultado (k), lo usamos como vector anterior (k-1) para la sigueinte
    # iteraación
    vct_X_Ant <- vct_X_Act

  }

  if (it==nbr_MaxIteraciones){
    print('Se llega al tope de iteraciones')
  }

  # Devolvemos el último vector calculado
  vct_X_Act

}

funcInterCambiarFilasVct <- function(vctOrigen, nbr_FilaOrigen, nbr_FilaDestino){
  # Intercambia las filas de un vector
  #
  # Parámetros
  # ----------
  # mtrx_A : vector
  #    El vector donde se realizará el intercambio de filas
  # nbr_FilaOrigen : número
  #    Índice de la fila origen que se moverá a la fila destino
  # nbr_FilaDestino : número
  #    Índice de la fila destino que se moverá a la fila origen
  #
  # Regresa
  # -------
  # vector
  #    El vector con los valores intercambiados
  #

  # Se guarda el valor destino
  nbr_ValorTmp <- vctOrigen[nbr_FilaDestino]

  # Se pone el valor origen hacia el valor destino
  vctOrigen[nbr_FilaDestino] <- vctOrigen[nbr_FilaOrigen]

  # Se recupera el valor destino original, y se pone en valor origen
  vctOrigen[nbr_FilaOrigen] <- nbr_ValorTmp

  # Se regresa el valor
  vctOrigen

}

funcInterCambiarFilasMtrx <- function(mtrx, nbr_FilaOrigen, nbr_FilaDestino, nbr_Cols){
  # Intercambia las filas de una matriz
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz donde se realizará el intercambio de filas
  # nbr_FilaOrigen : número
  #    Índice de la fila origen que se moverá a la fila destino
  # nbr_FilaDestino : número
  #    Índice de la fila destino que se moverá a la fila origen
  #
  # Regresa
  # -------
  # matriz
  #    La matriz con los valores intercambiados
  #

  # print('funcInterCambiarFilasMtrx')
  # print(nbr_FilaOrigen)
  # print(nbr_FilaDestino)

  # Se guarda el valor destino
  vct_FilaTmp <- mtrx[nbr_FilaDestino,1:nbr_Cols]

  # Se pone el valor origen hacia el valor destino
  mtrx[nbr_FilaDestino,1:nbr_Cols] <- mtrx[nbr_FilaOrigen,1:nbr_Cols]

  # Se recupera el valor destino original, y se pone en valor origen
  mtrx[nbr_FilaOrigen,1:nbr_Cols] <- vct_FilaTmp

  # Se regresa el valor
  mtrx

}

funcOrdenarEcuaciones <- function(mtrx_A, vct_B){
  # Ordena las ecuaciones del sistema buscando que no quede ningún cero
  # sobre la diagonal principal (no hay garantía de que no quede algún
  # cero sobre la diagonal). Para saber qué fila tomar, se hace una búsqueda
  # sobre cada columna preguntando por la norma infinito de cada vector-columna.
  # Puesto que el sistema de ecuaciones consta tanto de variables como de
  # resultados, es necesario tambén el re-acomodo del vector de resultados.
  #
  # Parámetros
  # ----------
  # mtrx_A : matriz
  #    La matriz que se va a ordenar
  # vct_B : vector
  #    El vector que se va a ordenar.
  #
  # Regresa
  # -------
  # list
  #    Una lista que contiene la matriz a evaluar y el vector de resultados.
  #

  # Variables que se usan dentro de la funcion
  nbr_Filas <- nrow(mtrx_A)
  nbr_Cols <- ncol(mtrx_A)

  # Se barren todas las columnas (iterador j)
  for (j in 1:(nbr_Cols-1)){
    # print('Inicia iteracion')

    # Se saca el vector-columna que se usará esta iteración
    vct_Col = mtrx_A[j:nbr_Cols,j]

    # Mostramos el vector-columna con el que trabajaremos
    # print(vct_Col)

    # Se obtiene la norma infinita del vector-columna
    nbr_Norm = Norm(vct_Col, p = Inf)
    # print(nbr_Norm)

    # Se pregunta si el valor es único en el vector-columna
    vct_OrdDesc <- sort(vct_Col, decreasing = TRUE)
    # print(vct_OrdDesc)

    # Preguntamos si el primer elemento del vector es diferente a la norma infinito
    # (eso significará que la norma infinito proviene de un número negativo)
    if (nbr_Norm != vct_OrdDesc[1]){
      vct_OrdDesc <- sort(vct_Col, decreasing = FALSE)
    }

    # Si sí es único:
    if (vct_OrdDesc[1] != vct_OrdDesc[2]){
      #print('Es unico')

      # Se obtiene el índice donde está ese valor
      nbr_Index <- match(nbr_Norm,vct_Col)
      # print(nbr_Index)

      # Si el índice es un NA
      if (is.na(nbr_Index)==TRUE){

        # Multiplicamos el valor de la norma infinito por -1
        nbr_Index <- match(nbr_Norm * -1,vct_Col)

      }

      nbr_Index <- nbr_Index + (j-1)
      # Para realizar el intercambio de filas, nuestra
      # fila origen será: nbr_Index, y la fila destino: j
      mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
      vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

      # print(mtrx_A)

    } else { # Si no es único:
      #print('Hay empate')

      vct_Bool1 <- (vct_Col==nbr_Norm)


      mtrx_Tmp <- mtrx_A[j:nbr_Cols, (j+1):nbr_Cols]
      mtrx_Tmp <- mtrx_Tmp[vct_Bool1, 1:(nbr_Cols-j)]
      #print(mtrx_Tmp)

      # Barremos el resto de las columans para el desempate
      for (jj in 1:(nbr_Cols-j)){

        # print(jj)
        vct_ColDesempate <- mtrx_Tmp[jj:(nbr_Cols-j+1),jj]

        # Buscaremos el valor mínimo de la siguiente columna
        vct_OrdAsc <- sort(vct_ColDesempate)
        # print(vct_OrdAsc)

        # Si el  mínimo es único:
        if (vct_OrdAsc[1] != vct_OrdAsc[2]){

          # print('es unico')
          # Generamos el vector que nos ayudará a obtener las filas a desempatar
          vct_Bool2 <- (vct_ColDesempate == vct_OrdAsc[1])
          # print(vct_Bool2)

          nbr_Index <- match(TRUE,vct_Bool2)
          nbr_Index <- nbr_Index + (j-1)

          # Para realizar el intercambio de filas, nuestra
          # fila origen será: nbr_Index, y la fila destino: j
          mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
          vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

          #print(mtrx_A)
          break

        }

      }

    }

  }

  # Regresamos en una lista, la matriz y vector ordenados
  list(matriz=mtrx_A,vector=vct_B)

}

funcResolverSE <- function(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo){
  # Resuleve un sistema de ecuaciones lineales mediante el método de Jacobi
  # o de Gauss-Seidel. El sistema de ecuaciones sólo se procesará si pasa
  # todas las validaciones requeridas.
  #
  # Parámetros
  # -------
  # mtrx_A : matriz
  #    Matriz a evaluar
  # vct_B : vector
  #    Vector de resultados del sistema de ecuaciones
  # vct_X0 : vector
  #    Vector de aproximaciones
  # nbr_MaxIteraciones : número
  #    Máximo número de iteraciones a alcanzar
  # nbr_Threshold : número
  #    Diferencia mínima a la que se quiere llegar entre iteraciones para
  #    considerar que el método ha convergido
  # str_Metodo : cadena
  #    Cadena mediante la cual se especifica el método que se empleará para
  #    actualizar el vector de aproximaciones.
  #
  # Regresa
  # -------
  # vector
  #    El vector de aproximaciones luego del proceso de iteraciones

  # Se agrega condicón para validar que la matriz no sea singular

  # Se inicializa el vector de resultados
  vct_XRslt <- rep(NA, size(vct_X0)[2])

  if(!is.singular.matrix(mtrx_A)){

    if (str_Metodo == 'J' || str_Metodo == 'GS'){

      if (str_Metodo=='J'){
        print('Solucion mediante metodo de Jacobi')
      }
      if (str_Metodo=='GS'){
        print('Solucion mediante metodo de Gauss-Seidel')
      }

      print('Matriz A:')
      print(mtrx_A)

      print('Vector b:')
      print(vct_B)

      # Se aplican las validaciones de manera anidada
      if (funcEsVectorValido(mtrx_A, vct_B)){

        if (funcEsVectorValido(mtrx_A, vct_X0)){

          if (funcEsMatrizCuadrada(mtrx_A) == TRUE){

            # Obtenemos la n de la matriz
            n <- nrow(mtrx_A)

            if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

              # Se manda a llamar la función que obtendrá la aproximación
              vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo)

              # Se imprime el resultado
              print('Resultado final: ')
              print(vct_XRslt)

            } else {
              print('La matriz tiene algun cero en la diagonal, comienza ordenamiento')

              lt_Obj <- funcOrdenarEcuaciones(mtrx_A, vct_B)
              mtrx_A <- lt_Obj$matriz
              vct_B <- lt_Obj$vector

              print('Matriz ordenada:')
              print(mtrx_A)

              print('Vector ordenado:')
              print(vct_B)

              if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

                # Se manda a llamar la función que obtendrá la aproximación
                vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo)

                # Se imprime el resultado
                print('Resultado final: ')
                print(vct_XRslt)

              } else {
                print('Pese al reordenamiento, aun hay ceros en la diagonal')
              }

            }

          } else {
              print('La matriz no cumple con ser de dimensiones nxn')
          }
        } else {
          print('El vector de aproximaciones no es de las dimensiones esperadas')
        }
      } else {
        print('El vector de resultados no es de las dimensiones esperadas')
      }

    }else{
      print("El metodo especificado no es valido, se espera 'GS' para Gauss-Seidel o 'J' para Jacobi")
    }
  }else{
    print('La matriz es singular, por lo tanto no hay solución al sistema y el método se detiene')
  }

  # Se devuelve el vector de resultados
  vct_XRslt

}

```

```{r, echo=F}

library(Matrix)

set.seed(123)
vec1 <- (sample.int(10,size=30,replace=TRUE))
vec2 <- (sample.int(10,size=30,replace=TRUE))

vals <- c(10*rnorm(30))
mode(vals) <- "integer"
mode(vals) <- "numeric"

A <- sparseMatrix(vec1, vec2, x=vals)              
A <- matrix(A,nrow = 10, ncol = 10)

b <- c(10*rnorm(10))
mode(b) <- "integer"
mode(b) <- "numeric"

x0 <- c(rep(0,10))

nbr_MaxIteraciones <- 10
nbr_Threshold <- 10**(-5)

print('Dimensiones matriz A:')
print(dim(A))

print('Dimensiones vector b:')
print(size(b))

print('Dimensiones punto inicial:')
print(size(x0))

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Verificamos que la matriz no es singular y su número de condición:
```{r}
is.singular.matrix(A)
cond(A)
```

El número de condición es grande.

Ejecutamos nuestro algoritmo:

```{r}
funcResolverSE(A, b, x0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)
```

Como ocurrió en este ejercicio, en las matrices ralas existe el riesgo que a pesar del ordenamiento de renglones, la matriz resultante tenga ceros en la diagonal y por lo tanto no se pueda ejecutar el método de Jacobi.

Creamos ahora una matriz con menos ceros:

```{r, echo=F}

set.seed(123)
vec1 <- (sample.int(10,size=50,replace=TRUE))
vec2 <- (sample.int(10,size=50,replace=TRUE))

vals <- c(10*rnorm(50))
mode(vals) <- "integer"
mode(vals) <- "numeric"

A <- sparseMatrix(vec1, vec2, x=vals)              
A <- matrix(A,nrow = 10, ncol = 10)

b <- c(10*rnorm(10))
mode(b) <- "integer"
mode(b) <- "numeric"

x0 <- c(rep(0,10))

nbr_MaxIteraciones <- 20
nbr_Threshold <- 10**(-5)

print('Dimensiones matriz A:')
print(dim(A))

print('Dimensiones vector b:')
print(size(b))

print('Dimensiones punto inicial:')
print(size(x0))

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Verificamos que la matriz no es singular y su número de condición:
```{r}
is.singular.matrix(A)
cond(A)
```

Nuestro algoritmo devuelve:

```{r}
funcResolverSE(A, b, x0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)
```

En esta caso sí se consiguió obtener una matriz sin ceros en la diagonal, pero no converge el algorimto, notemos además que la matriz no es dominante estricta en la diagonal por renglones.

Ejecutamos la función ```lsolve.jacobi```con esta matriz $A$ ordenada mediante nuestra función *funcOrdenarEcuaciones*, obteniendo:


```{r}
lt_Obj <- funcOrdenarEcuaciones(A, b)
mat_A <- lt_Obj$matriz
vct_B <- lt_Obj$vector
mat_A
```

Ahora probamos el método  ```lsolve.jacobi``` :

```{r message=FALSE}

sol.lsolve <- lsolve.jacobi(mat_A, vct_B, xinit = x0, reltol = nbr_Threshold,  maxiter = nbr_MaxIteraciones, adjsym = FALSE, verbose = TRUE)

sol.lsolve$x
sol.lsolve$iter
```

El cual tampoco converge.

Probamos ahora el método con una matriz rala y dominante estricta en la diagonal pro renglones:

```{r, echo = F}

Ad <- A
diag(Ad) <- 70+diag(A)
Ad

print('Dimensiones matriz A:')
print(dim(Ad))

print('Dimensiones vector b:')
print(size(b))

print('Dimensiones punto inicial:')
print(size(x0))

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)


```

Su número de condición es:

```{r}
cond(A)
```



```{r}
funcResolverSE(Ad, b, x0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)

```

Convergiendo el método en la décima iteración.

Lo comparamos con la librería ```Rlinsolve```:

```{r, message=F}
sol.lsolve <- lsolve.jacobi(Ad, b, xinit = x0, reltol = nbr_Threshold,  maxiter = nbr_MaxIteraciones, adjsym = FALSE, verbose = TRUE)
sol.lsolve$x
sol.lsolve$iter

```

Coincidiendo en alrededor de 5 decimales con nuestra implementción.



Finalmente, probamos con matrices sparse de dimensiones $10^2 \times 10^2$:

```{r, echo=F}

funcEsVectorValido <- function(mtrx, vct){
  # Valida si el vector (ya sea de resultados o aproximaciones) cuenta
  # con la misma cantidad de filas que la matriz a evaluar.
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz a evaluar
  # vct : vector
  #    El vector cuyo número de filas se comparará contra las de la matriz a evaluar
  #
  # Regresa
  # -------
  # boolean
  #    Una bandera a manera de booleano indicando si la cantidad de filas del
  #    vector es igual o no a la cantidad de filas de la matriz a evaluar.
  #

  # El vector b debe tener la misma cantidad de filas que la matriz
  bool_VectorValido = FALSE
  if (nrow(mtrx) == length(vct)){
    bool_VectorValido = TRUE
  }

  bool_VectorValido

}

# Valida que sea cuadrada la matriz
funcEsMatrizCuadrada <- function(mtrx){
  # Valida si la matriz es cuadrada (nxn)
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz a evaluar
  #
  # Regresa
  # -------
  # boolean
  #    Una bandera a manera de booleano indicando si la cantidad de filas y
  #    columnas de la matriz son iguales.
  #

  # Si el número de filas es igual al número de columnas, es una matriz cuadrada
  if (nrow(mtrx)==ncol(mtrx)){
    bool_Valida <- TRUE
  }
  else{
    bool_Valida <- FALSE
  }

  bool_Valida

}

 # Busca algún cero en la diagonal principal
funcHayCeroEnDiagonal <- function(mtrx){
  # Valida si se presenta algún cero en la diagonal de la matriz
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz a evaluar
  #
  # Regresa
  # -------
  # boolean
  #    Una bandera a manera de booleano indicando si se encontró un cero en
  #    la diagonal de la matriz.
  #

  bool_HayCero <- FALSE
  nbr_Filas <- nrow(mtrx)
  nbr_Cols <- ncol(mtrx)

  for (i in 1:nbr_Filas){
    for (j in 1:nbr_Cols){
      if ((i==j) && (mtrx[i,j]==0)){
        bool_HayCero <- TRUE
      }
    }
  }

  bool_HayCero

}

# Función que obtiene cada componente del vector
funcObtenerComponente <- function(i, n, mtrx_A, vct_X, vct_B){
  # Obtiene un solo componente del vector de aproximaciones
  #
  # Parámetros
  # ----------
  # i : número
  #    Indíce del componente (del vector de aproximaciones) que se quiere obtener
  # n : número
  #    Dimensión de filas o columnas de la matriz
  # mtrx_A: matriz
  #    La matriz que se está evaluando
  # vct_X : vector
  #    Vector de aproximaciones
  # vct_B : vector
  #    Vector de resultados del sistema de ecuaciones
  #
  # Regresa
  # -------
  # número
  #    El valor del componente indicado para el vector de aproximaciones
  #

  # Variable en la cual acumularemos el resutlado de la sumatoria
  nbr_Sumatoria = 0
  nbr_Final = 0

  # Variables con los términos agrupados de los elementos de la fórmula
  nbr_Termino1 = 0
  nbr_Termino2 = 0

  # Sumatoria de j a n para toda j != i
  for (j in 1:n){
    if (j != i ){

      # Operación de la sumatoria
      nbr_Termino1 = (-(mtrx_A[i,j] * vct_X[j]) / (mtrx_A[i,i]))

      # Acumulamos los valores
      nbr_Sumatoria = nbr_Sumatoria + nbr_Termino1

    }
  }

  # Terminada la sumatoria, se prepara un término extra
  nbr_Termino2 = (vct_B[i] / mtrx_A[i,i])

  # El resultado final es lo acumulado de la sumatoria más el otro término
  nbr_Final = nbr_Sumatoria + nbr_Termino2

  # Regresamos el resultado
  nbr_Final

}

# Función que obtiene la aproximación de las iteraciones
funcObtenerVctRslt <- function(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo){
  # Mediante un proceso de iteraciones, actualiza el vector de aproximaciones
  # vct_X0 para lograr la igualdad: mtrx_A * vct_X0 = vct_B
  # El proceso de iteraciones está sujeto a que se cumpla alguna de las
  # siguientes 2 condiciones:
  #   1: Alcanzar el máximo número de iteraciones (especificado en el parámetro
  #     nbr_MaxIteraciones)
  #   2: Lograr llegar a un diferencia entre iteraciones menor al threshold
  #     que se especifica en el parámetro nbr_Threshold.
  # En cuanto se cumpla alguna de dichas condiciones, termina el proceso de
  # iteraciones.
  # Adicionalmente, hay 2 maneras de calcular el vector de resultados, mediante
  # el método Jacobi o Gauss-Seidel. La manera de especificar qué método se
  # quiere emplear es con el parámetro: str_Metodo que se emplea de la
  # siguiente manera:
  # Si el valor de str_Metodo es 'J', se emplea el método Jacobi
  # Si el valor de str_Metodo es 'GS', se emplea el método Gauss-Seidel
  #
  # Parámetros
  # ----------
  # nbr_MaxIteraciones : número
  #    Máximo número de iteraciones a alcanzar
  # n : Número
  #    Dimensión de filas o columnas de la matriz
  # mtrx_A : matriz
  #    Matriz a evaluar
  # vct_B : vector
  #    Vector de resultados del sistema de ecuaciones
  # vct_X0 : vector
  #    Vector de aproximaciones
  # nbr_Threshold : número
  #    Diferencia mínima a la que se quiere llegar entre iteraciones para
  #    considerar que el método ha convergido
  # str_Metodo : cadena
  #    Cadena mediante la cual se especifica el método que se empleará para
  #    actualizar el vector de aproximaciones.
  #
  # Regresa
  # -------
  # vector
  #    El vector de aproximaciones actualizado luego del proceso de iteraciones
  #

  # Inicializamos los vectores de control
  vct_X_Act <- vct_X0
  vct_X_Ant <- vct_X0

  # Los siguientes prints son para debuguear, más adelante se eliminarán
  print(paste0('Iteracion ', 0))
  print(vct_X_Act)

  # Máximo número de iteraciones
  for (it in 1:nbr_MaxIteraciones){

    print(paste0('Iteracion ', it))

    # Iteraciones para obtener cada componente del vector de resultados
    for (i in 1:n){

      # Si se pidió usar el método Jacobi
      if (str_Metodo=='J'){
        vct_X_Act[i]=funcObtenerComponente(i, n, mtrx_A, vct_X_Ant, vct_B)
      }

      # Si se pidió usar el método Gauss-Seidel
      if (str_Metodo=='GS'){
        vct_X_Act[i]=funcObtenerComponente(i, n, mtrx_A, vct_X_Act, vct_B)
      }

    }

    print(vct_X_Act)

    nbr_Numerador <- Norm(vct_X_Act - vct_X_Ant, p = Inf)
    nbr_Denominador <- Norm(vct_X_Act, p = Inf)

    print(paste0('nbr_Numerador: ', nbr_Numerador))
    print(paste0('nbr_Denominador: ', nbr_Denominador))

    nbr_Diff <-  nbr_Numerador / nbr_Denominador
    print(paste0('nbr_Diff: ',nbr_Diff))

    # Si se empiezan a obtener valores NaN, significa que no hay solución
    if (is.na(nbr_Diff)){
      print('No hay convergencia')
      vct_X_Act <- rep(NA, size(vct_X0)[2])
      break
    }

    # Si se llega a una diferencia menor al threshold indicado, salimos del for
    if (nbr_Diff<nbr_Threshold){
      print('Se alcanza el threshold')
      break
    }

    # El vector resultado (k) lo usamos como vector anterior (k-1) para la sigueinte
    # iteraación
    vct_X_Ant <- vct_X_Act

  }

  if (it==nbr_MaxIteraciones){
    print('Se llega al tope de iteraciones')
  }

  # Devolvemos el último vector calculado
  vct_X_Act

}

funcInterCambiarFilasVct <- function(vctOrigen, nbr_FilaOrigen, nbr_FilaDestino){
  # Intercambia las filas de un vector
  #
  # Parámetros
  # ----------
  # mtrx_A : vector
  #    El vector donde se realizará el intercambio de filas
  # nbr_FilaOrigen : número
  #    Índice de la fila origen que se moverá a la fila destino
  # nbr_FilaDestino : número
  #    Índice de la fila destino que se moverá a la fila origen
  #
  # Regresa
  # -------
  # vector
  #    El vector con los valores intercambiados
  #

  # Se guarda el valor destino
  nbr_ValorTmp <- vctOrigen[nbr_FilaDestino]

  # Se pone el valor origen hacia el valor destino
  vctOrigen[nbr_FilaDestino] <- vctOrigen[nbr_FilaOrigen]

  # Se recupera el valor destino original, y se pone en valor origen
  vctOrigen[nbr_FilaOrigen] <- nbr_ValorTmp

  # Se regresa el valor
  vctOrigen

}

funcInterCambiarFilasMtrx <- function(mtrx, nbr_FilaOrigen, nbr_FilaDestino, nbr_Cols){
  # Intercambia las filas de una matriz
  #
  # Parámetros
  # ----------
  # mtrx : matriz
  #    La matriz donde se realizará el intercambio de filas
  # nbr_FilaOrigen : número
  #    Índice de la fila origen que se moverá a la fila destino
  # nbr_FilaDestino : número
  #    Índice de la fila destino que se moverá a la fila origen
  #
  # Regresa
  # -------
  # matriz
  #    La matriz con los valores intercambiados
  #

  # print('funcInterCambiarFilasMtrx')
  # print(nbr_FilaOrigen)
  # print(nbr_FilaDestino)

  # Se guarda el valor destino
  vct_FilaTmp <- mtrx[nbr_FilaDestino,1:nbr_Cols]

  # Se pone el valor origen hacia el valor destino
  mtrx[nbr_FilaDestino,1:nbr_Cols] <- mtrx[nbr_FilaOrigen,1:nbr_Cols]

  # Se recupera el valor destino original, y se pone en valor origen
  mtrx[nbr_FilaOrigen,1:nbr_Cols] <- vct_FilaTmp

  # Se regresa el valor
  mtrx

}

funcOrdenarEcuaciones <- function(mtrx_A, vct_B){
  # Ordena las ecuaciones del sistema buscando que no quede ningún cero
  # sobre la diagonal principal (no hay garantía de que no quede algún
  # cero sobre la diagonal). Para saber qué fila tomar, se hace una búsqueda
  # sobre cada columna preguntando por la norma infinito de cada vector-columna.
  # Puesto que el sistema de ecuaciones consta tanto de variables como de
  # resultados, es necesario tambén el re-acomodo del vector de resultados.
  #
  # Parámetros
  # ----------
  # mtrx_A : matriz
  #    La matriz que se va a ordenar
  # vct_B : vector
  #    El vector que se va a ordenar.
  #
  # Regresa
  # -------
  # list
  #    Una lista que contiene la matriz a evaluar y el vector de resultados.
  #

  # Variables que se usan dentro de la función
  nbr_Filas <- nrow(mtrx_A)
  nbr_Cols <- ncol(mtrx_A)

  bool_NrmInfPos <- TRUE

  # Se barren todas las columnas (iterador j)
  for (j in 1:(nbr_Cols-1)){
    #print('Inicia iteracion')
    #print(j)
    bool_NrmInfPos <- TRUE

    # Se saca el vector-columna que se usará en esta iteración
    vct_Col = mtrx_A[j:nbr_Cols,j]

    # Mostramos el vector-columna con el que trabajaremos
    # print(vct_Col)

    # Se obtiene la norma infinita del vector-columna
    nbr_Norm = Norm(vct_Col, p = Inf)
    # print(nbr_Norm)

    # Se pregunta si el valor es único en el vector-columna
    vct_OrdDesc <- sort(vct_Col, decreasing = TRUE)
    # print(vct_OrdDesc)

    # Preguntamos si el primer elemento del vector es diferente a la norma infinito
    # (eso significará que la norma infinito proviene de un número negativo)
    if (nbr_Norm != vct_OrdDesc[1]){
      vct_OrdDesc <- sort(vct_Col, decreasing = FALSE)
      bool_NrmInfPos <- FALSE
    }

    # Si sí es único:
    if (vct_OrdDesc[1] != vct_OrdDesc[2]){
      #print('Es unico')

      # Se obtiene el índice donde está ese valor
      nbr_Index <- match(nbr_Norm,vct_Col)
      # print(nbr_Index)

      # Si el índice es un NA
      if (is.na(nbr_Index)==TRUE){

        # Multiplicamos el valor de la norma infinito por -1
        nbr_Index <- match(nbr_Norm * -1,vct_Col)

      }

      nbr_Index <- nbr_Index + (j-1)
      # Para realizar el intercambio de filas, nuestra
      # fila origen será: nbr_Index, y la fila destino: j
      mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
      vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

      # print(mtrx_A)

    } else { # Si no es único:

      # Preguntamos si la norma infinito viene de un positivo o negativo
      if (bool_NrmInfPos==FALSE){
        # La multiplicamos por -1 para que haya coincidencias
        nbr_Norm = nbr_Norm * -1
      }

      #if (j==94) {
        #print('Hay empate')

        #print('mtrx_A')
        #print(mtrx_A)

        #print('nbr_Norm')
        #print(nbr_Norm)

        #print('vct_Col')
        #print(vct_Col)
      #}

      vct_Bool1 <- (vct_Col==nbr_Norm)

      # Si se trata de la última columna, es un caso especial
      if ((j+1)==nbr_Cols){
        #print('Caso especial')
        mtrx_Tmp1 <- mtrx_A[j:nbr_Cols, (j+1):nbr_Cols]
        mtrx_Tmp1 <- rbind(mtrx_Tmp1)
        mtrx_Tmp1 <- t(mtrx_Tmp1)

        mtrx_Tmp2 <- mtrx_Tmp1[vct_Bool1, 1:(nbr_Cols-j)]
        mtrx_Tmp2 <- rbind(mtrx_Tmp2)
        mtrx_Tmp2 <- t(mtrx_Tmp2)

      }else{ # Este es el caso normal
        mtrx_Tmp1 <- mtrx_A[j:nbr_Cols, (j+1):nbr_Cols]
        mtrx_Tmp2 <- mtrx_Tmp1[vct_Bool1, 1:(nbr_Cols-j)]
      }

      #if (j==94) {
        #print('mtrx_Tmp1 pt1')
        #print(mtrx_Tmp1)
        #print('dim')
        #print(dim(mtrx_Tmp1))
        #print('vct_Bool1')
        #print(vct_Bool1)
        #print('mtrx_Tmp2 pt2')
        #print(mtrx_Tmp2)
        #print('dim')
        #print(dim(mtrx_Tmp2))
      #}


      # Barremos el resto de las columnas para el desempate
      for (jj in 1:(nbr_Cols-j)){
        #print('j')
        #print(j)
        #print('jj')
        #print(jj)
        #print('nrow(mtrx_Tmp2)')
        #print(nrow(mtrx_Tmp2))
        vct_ColDesempate <- mtrx_Tmp2[jj:nrow(mtrx_Tmp2),jj]

        # Buscaremos el valor mínimo de la siguiente columna
        vct_OrdAsc <- sort(vct_ColDesempate)
        #print(vct_OrdAsc)

        # Si el  mínimo es único:
        if (vct_OrdAsc[1] != vct_OrdAsc[2]){

          #print('es unico')
          # Generamos el vector que nos ayudará a obtener las filas a desempatar
          vct_Bool2 <- (vct_ColDesempate == vct_OrdAsc[1])
          #print(vct_Bool2)

          # Ya que tenemos el vector que dice cuál es la fila que debemos tomar
          # vamos yendo hacia atrás para averiguar el índice relativo de
          # en columna con la que estamos trabajando
          #print('Comienza regreso')
          vct_Tmp1 <- mtrx_Tmp2[vct_Bool2]
          #print('vct_Tmp1')
          #print(vct_Tmp1)

          vct_Bool3 <- (vct_Tmp1==mtrx_Tmp1)
          #print('vct_Bool3')
          #print(vct_Bool3)

          vct_bool4 <- apply(mtrx_Tmp1, 1, function(x) all(x==vct_Tmp1))
          #print('vct_bool4')
          #print(vct_bool4)

          nbr_Index <- match(TRUE, vct_bool4)
          # nbr_Index <- match(TRUE,vct_Bool2)
          #print('nbr_Index')
          #print(nbr_Index)
          nbr_Index <- nbr_Index + (j-1)

          # Para realizar el intercambio de filas, nuestra
          # fila origen será: nbr_Index y la fila destino: j
          mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
          vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

          #print(mtrx_A)
          break

        }

      }

    }

  }

  # Regresamos en una lista, la matriz y vector ordenados
  list(matriz=mtrx_A,vector=vct_B)

}

funcResolverSE <- function(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo){
  # Resuelve un sistema de ecuaciones lineales mediante el método de Jacobi
  # o de Gauss-Seidel. El sistema de ecuaciones sólo se procesará si pasa
  # todas las validaciones requeridas.
  #
  # Parámetros
  # -------
  # mtrx_A : matriz
  #    Matriz a evaluar
  # vct_B : vector
  #    Vector de resultados del sistema de ecuaciones
  # vct_X0 : vector
  #    Vector de aproximaciones
  # nbr_MaxIteraciones : número
  #    Máximo número de iteraciones a alcanzar
  # nbr_Threshold : número
  #    Diferencia mínima a la que se quiere llegar entre iteraciones para
  #    considerar que el método ha convergido
  # str_Metodo : cadena
  #    Cadena mediante la cual se especifica el método que se empleará para
  #    actualizar el vector de aproximaciones.
  #
  # Regresa
  # -------
  # vector
  #    El vector de aproximaciones luego del proceso de iteraciones

  # Se agrega condicón para validar que la matriz no sea singular

  # Se inicializa el vector de resultados
  vct_XRslt <- rep(NA, size(vct_X0)[2])

  if(!is.singular.matrix(mtrx_A)){

    if (str_Metodo == 'J' || str_Metodo == 'GS'){

      if (str_Metodo=='J'){
        print('Solución mediante metodo de Jacobi')
      }
      if (str_Metodo=='GS'){
        print('Solución mediante metodo de Gauss-Seidel')
      }

      print('Matriz A:')
      print(mtrx_A)

      print('Vector b:')
      print(vct_B)

      # Se aplican las validaciones de manera anidada
      if (funcEsVectorValido(mtrx_A, vct_B)){

        if (funcEsVectorValido(mtrx_A, vct_X0)){

          if (funcEsMatrizCuadrada(mtrx_A) == TRUE){

            # Obtenemos la n de la matriz
            n <- nrow(mtrx_A)

            if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

              # Se manda a llamar la función que obtendrá la aproximación
              vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo)

              # Se imprime el resultado
              print('Resultado final: ')
              print(vct_XRslt)

            } else {
              print('La matriz tiene algún cero en la diagonal, comienza ordenamiento')

              # Respaldo del orden original
              mtrx_Original <- mtrx_A
              vct_Original <- vct_B

              lt_Obj <- funcOrdenarEcuaciones(mtrx_A, vct_B)
              mtrx_A <- lt_Obj$matriz
              vct_B <- lt_Obj$vector

              print('Matriz ordenada:')
              print(mtrx_A)

              print('Vector ordenado:')
              print(vct_B)

              if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

                # Se manda a llamar la función que obtendrá la aproximación
                vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo)

                # Se imprime el resultado
                print('Resultado final (nuevo orden): ')
                print(vct_XRslt)

                # Se reordena el vector de resultados para entregarlo en el mismo
                # orden en que fue solicitado
                nbr_Filas <-size(vct_XRslt)[2]
                for (i in 1:nbr_Filas){
                  for (j in 1:nbr_Filas){
                    if (sum(mtrx_A[i,]==mtrx_Original[j,]) == nbr_Filas){
                      mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, i, j, nbr_Filas)
                      vct_XRslt <- funcInterCambiarFilasVct(vct_XRslt, i, j)
                    }
                  }
                }
                print('Resultado final (orden original): ')
                print(vct_XRslt)

              } else {
                print('Pese al reordenamiento, aún hay ceros en la diagonal')
              }

            }

          } else {
              print('La matriz no cumple con ser de dimensiones nxn')
          }
        } else {
          print('El vector de aproximaciones no es de las dimensiones esperadas')
        }
      } else {
        print('El vector de resultados no es de las dimensiones esperadas')
      }

    }else{
      print("El método especificado no es válido, se espera 'GS' para Gauss-Seidel o 'J' para Jacobi")
    }
  }else{
    print('La matriz es singular, por lo tanto no hay solución al sistema y el método se detiene')
  }

  # Se devuelve el vector de resultados
  vct_XRslt

}


```

```{r, echo=F}
set.seed(12345)
vec1 <- (sample.int(100,size=5000,replace=TRUE))

vec2 <- (sample.int(100,size=5000,replace=TRUE))

vals <- c(10*rnorm(5000))
mode(vals) <- "integer"
mode(vals) <- "numeric"

A <- sparseMatrix(vec1, vec2, x=vals)              
A <- matrix(A,nrow = 100, ncol = 100)

b <- c(10*rnorm(100))

mode(b) <- "integer"
mode(b) <- "numeric"

x0 <- c(rep(0,100))

nbr_MaxIteraciones <- 10
nbr_Threshold <- 10**(-5)

print('Dimensiones matriz A:')
print(dim(A))

print('Dimensiones vector b:')
print(size(b))

print('Dimensiones punto inicial:')
print(size(x0))

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)


```

```{r}

funcResolverSE(A, b, x0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)


```

Nuevamente ocurre que al ser una matriz rala, a pesar del reordenamiento de filas, no es posible eliminar todos los ceros de la diagonal. Adicionalmente su número de condición es grande:


```{r}
cond(A)
```

Probando ahora el algoritmo en una matriz dominante estricta en la diagonal por renglones, obtenemos:

```{r, echo=F}

Ad <- A
diag(Ad) <- 1000 + diag(A)

```

```{r}
funcResolverSE(Ad, b, x0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)

```
Converge en la iteración 6 dado el threshold de $10^{-5}$. Esta matriz tiene un número de condición cercano a 1:


Su número de condición es:

```{r}
cond(Ad)
```



# Conclusión

Mediante las pruebas de este documento, se concluye que la implementación del método Jacobi es adecuada pues cumple con los siguientes puntos:

+ Valida las dimensiones de sus input: matriz A, vector b, vector x0
+ Ordena las filas para buscar eliminar todos los ceros de la diagonal, si después del ordenamiento sigue habiendo ceros en la diagonal, se detiene el algoritmo
+ Si la matriz es singular no continúa el algoritmo
+ El método converge cuando la matriz es dominante diagonal estricta por renglones
+ Los resultados de la implementación coinciden con los del paquete ```Rlinsolve``` en alrededor de 5 decimales cuando hay convergencia

