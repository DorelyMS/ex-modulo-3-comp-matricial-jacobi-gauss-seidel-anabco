---
title: "Pruebas Método Jacobi"
author: ""
date: ""
#output: html_document
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Pruebas con Primera Versión

En esta versión no se incluye aún el threshold como un criterio de paro del algoritmo, únicamente las iteraciones indican cuándo termina el algoritmo.

```{r , warning = FALSE, echo=FALSE }
library('pracma')

funcEsVectorValido <- function(mtrx, vct){

  # El vector b, debe tener la misma cantidad de filas que la matriz
  bool_VectorValido = FALSE
  if (nrow(mtrx) == length(vct)){
    bool_VectorValido = TRUE
  }

  bool_VectorValido

}

# Valida que sea cuadrada la matriz
funcEsMatrizCuadrada <- function(mtrx){

  # Si el número de filas es igual al número de columnas, es una matriz cuadrada
  if (nrow(mtrx)==ncol(mtrx)){
    bool_Valida <- TRUE
  }
  else{
    bool_Valida <- FALSE
  }

  bool_Valida

}

 # Busca algún cero en la diagonal principal
funcHayCeroEnDiagonal <- function(mtrx){

  bool_HayCero <- FALSE
  nbr_Filas <- nrow(mtrx)
  nbr_Cols <- ncol(mtrx)

  for (i in 1:nbr_Filas){
    for (j in 1:nbr_Cols){
      if ((i==j) && (mtrx[i,j]==0)){
        bool_HayCero <- TRUE
      }
    }
  }

  bool_HayCero

}

# Función que obtiene cada componente del vector
funcObtenerComponente <- function(i, n, mtrx_A, vct_X, vct_B){

  # Variable en la cual acumularemos el resutlado de la sumatoria
  nbr_Sumatoria = 0
  nbr_Final = 0

  # Variables con los términos agrupados de los elementos de la fórmula
  nbr_Termino1 = 0
  nbr_Termino2 = 0

  # Sumatoria de j a n para toda j != i
  for (j in 1:n){
    if (j != i ){

      # Operación de la sumatoria
      nbr_Termino1 = (-(mtrx_A[i,j] * vct_X[j]) / (mtrx_A[i,i]))

      # Acumulamos los valores
      nbr_Sumatoria = nbr_Sumatoria + nbr_Termino1

    }
  }

  # Terminada la sumatoria, se prepara un término extra
  nbr_Termino2 = (vct_B[i] / mtrx_A[i,i])

  # El resultado final, es lo acumulado de la sumatoria más el otro término
  nbr_Final = nbr_Sumatoria + nbr_Termino2

  # Regresamos el resultado
  nbr_Final

}

# Función que obtiene la aproximación de las iteraciones
funcObtenerVctRslt <- function(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0){

  # Inicializamos los vectores de control
  vct_X_Act <- vct_X0
  vct_X_Ant <- vct_X0

  # Los siguientes prints son para debuguear, más adelante se eliminarán
  print(paste0('Iteracion ', 0))
  print(vct_X_Act)

  # Máximo número de iteraciones
  for (it in 1:nbr_MaxIteraciones){

    # Iteraciones para obtener cada componente del vector de resultados
    for (i in 1:n){
      vct_X_Act[i]=funcObtenerComponente(i, n, mtrx_A, vct_X_Ant, vct_B)
    }

    # El vector resultado (k), lo usamos como vector anterior (k-1) para la sigueinte
    # iteraación
    vct_X_Ant <- vct_X_Act

    # Los siguientes prints son para debuguear, más adelante se eliminarán
    print(paste0('Iteracion ', it))
    print(vct_X_Act)

  }

  # Devolvemos el último vector calculado
  vct_X_Act

}

funcInterCambiarFilasVct <- function(vctOrigen, nbr_FilaOrigen, nbr_FilaDestino){

  # Se guarda el valor destino
  nbr_ValorTmp <- vctOrigen[nbr_FilaDestino]

  # Se pone el valor origen hacia el valor destino
  vctOrigen[nbr_FilaDestino] <- vctOrigen[nbr_FilaOrigen]

  # Se recupera el valor destino original, y se pone en valor origen
  vctOrigen[nbr_FilaOrigen] <- nbr_ValorTmp

  # Se regresa el valor
  vctOrigen

}

funcInterCambiarFilasMtrx <- function(mtrx, nbr_FilaOrigen, nbr_FilaDestino, nbr_Cols){

  # Se guarda el valor destino
  vct_FilaTmp <- mtrx[nbr_FilaDestino,1:nbr_Cols]

  # Se pone el valor origen hacia el valor destino
  mtrx[nbr_FilaDestino,1:nbr_Cols] <- mtrx[nbr_FilaOrigen,1:nbr_Cols]

  # Se recupera el valor destino original, y se pone en valor origen
  mtrx[nbr_FilaOrigen,1:nbr_Cols] <- vct_FilaTmp

  # Se regresa el valor
  mtrx

}

funcOrdenarEcuaciones <- function(mtrx_A, vct_B){

  # Variables que se usan dentro de la funcion
  nbr_Filas <- nrow(mtrx_A)
  nbr_Cols <- ncol(mtrx_A)

  # Se barren todas las columnas (iterador j)
  for (j in 1:nbr_Cols){
    # print('Inicia iteracion')

    # Se saca el vector-columna que se usará esta iteración
    vct_Col = mtrx_A[1:nbr_Cols,j]

    # Mostramos el vector-columna con el que trabajaremos
    # print(vct_Col)

    # Se obtiene la norma infinita del vector-columna
    nbr_Norm = Norm(vct_Col, p = Inf)
    # print(nbr_Norm)

    # Se pregunta si el valor es único en el vector-columna
    vct_OrdDesc <- sort(vct_Col, decreasing = TRUE)
    # print(vct_OrdDesc)

    # Si sí es único:
    if (vct_OrdDesc[1] != vct_OrdDesc[2]){
      #print('Es unico')
      # Se obtiene el índice donde está ese valor
      nbr_Index <- match(nbr_Norm,vct_Col)
      # print(nbr_Index)

      # Para realizar el intercambio de filas, nuestra
      # fila origen será: nbr_Index, y la fila destino: j
      mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
      vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

      # print(mtrx_A)

    } else { # Si no es único:
      #print('Hay empate')

      vct_Bool1 <- (vct_Col==nbr_Norm)

      mtrx_Tmp <- mtrx_A[vct_Bool1,1:nbr_Cols]
      #print(mtrx_Tmp)

      # Barremos el resto de las columans para el desempate
      for (jj in (j+1):nbr_Cols){

        vct_ColDesempate <- mtrx_Tmp[,jj]
        # print(paste0('vct_ColDesempate: ', vct_ColDesempate))

        # Buscaremos el valor mínimo de la siguiente columna
        vct_OrdAsc <- sort(vct_ColDesempate)
        # print(vct_OrdAsc)

        # Si el  mínimo es único:
        if (vct_OrdAsc[1] != vct_OrdAsc[2]){

          # print('es unico')
          # Generamos el vector que nos ayudará a obtener las filas a desempatar
          vct_Bool2 <- (vct_ColDesempate == vct_OrdAsc[1])
          # print(vct_Bool2)

          vct_FilaDesempate <- mtrx_Tmp[vct_Bool2]

          # Ya que se tiene la fila mínima del empate, se obtiene su indice
          # en la matriz_A
          vct_Bool3 <- rowSums(mtrx_A == vct_FilaDesempate[col(mtrx_A)]) == ncol(mtrx_A)
          nbr_Index <- match(TRUE,vct_Bool3)

          # Para realizar el intercambio de filas, nuestra
          # fila origen será: nbr_Index, y la fila destino: j
          mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
          vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

          #print(mtrx_A)
          break

        }

      }

    }

  }

  # Regresamos en una lista, la matriz y vector ordenados
  list(matriz=mtrx_A,vector=vct_B)

}


funcMetodoJacobi <- function(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones){

  print('Matriz A:')
  print(mtrx_A)

  print('Vector b:')
  print(vct_B)

  # Se aplican las validaciones de manera anidada
  if (funcEsVectorValido(mtrx_A, vct_B)){

    if (funcEsVectorValido(mtrx_A, vct_X0)){

      if (funcEsMatrizCuadrada(mtrx_A) == TRUE){

        # Obtenemos la n de la matriz
        n <- nrow(mtrx_A)

        if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

          # Se manda a llamar la función que obtendrá la aproximación
          vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0)

          # Se imprime el resultado
          print('Resultado final: ')
          print(vct_XRslt)

        } else {
          print('La matriz tiene algun cero en la diagonal, comienza ordenamiento')

          lt_Obj <- funcOrdenarEcuaciones(mtrx_A, vct_B)
          mtrx_A <- lt_Obj$matriz
          vct_B <- lt_Obj$vector

          print('Matriz ordenada:')
          print(mtrx_A)

          print('Vector ordenado:')
          print(vct_B)

          if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

            # Se manda a llamar la función que obtendrá la aproximación
            vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0)

            # Se imprime el resultado
            print('Resultado final: ')
            print(vct_XRslt)

          } else {
            print('Pese al reordenamiento, aun hay ceros en la diagonal')
          }

        }

      } else {
          print('La matriz no cumple con ser de dimensiones nxn')
      }
    } else {
      print('El vector de aproximaciones, debe tener la misma cantidad de filas que la matriz a evaluar')
    }
  } else {
    print('El vector de resultados, debe tener la misma cantidad de filas que la matriz a evaluar')
  }
}


```

## Prueba con Ejemplo de Clase

La primera prueba es con la matriz ejemplo que se muestra en la nota de métodos iterativos [Jacobi y Gauss-Seidel](https://github.com/ITAM-DS/analisis-numerico-computo-cientifico/blob/master/temas/III.computo_matricial/3.3.e.Jacobi_Gauss-Seidel.ipynb) de nuestra materia de Métodos Numéricos y Optimización.

```{r, echo=FALSE }
mtrx_A <- matrix(c( 0,3,-1,8,
                   -1,11,-1,3,
                    2,-1,10,-1,
                    10,-1,2,0),
                 byrow = TRUE,
                 nrow=4,
                 ncol=4)

vct_B <- c(15, 25, -11, 6)

vct_X0 <- c(0,0,0,0)

nbr_MaxIteraciones <- 10

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)
```

Ejecutamos el método de Jacobi:

```{r, echo=TRUE}

funcMetodoJacobi(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones)
```

En la décima iteración se llega al resultado de la nota, además la primera y segunda iteración cuadran con lo mostrado en la misma nota, lo cual indica que el algoritmo programado está realizando el método de forma adecuada.

Adicionalmente, reordena las ecuaciones para no tener ceros en la diagonal, eligiendo el elemento de máxima magnitud.

Contrastamos ahora esta solución con un método Jacobi ya implementado en la librería *Rlinsolve*:

```{r, warning=FALSE, echo=FALSE, message = FALSE}
library(Rlinsolve)
```

```{r, echo=FALSE}
#ordenarla, pues de lo contrario lsolve.jacobi ya no cuadra
mtrx_A <- matrix(c( 10,-1,2,0,
                    -1,11,-1,3,
                    2,-1,10,-1,
                    0,3,-1,8),
                 byrow = TRUE,
                 nrow=4,
                 ncol=4)

vct_B <- c(6, 25, -11, 15)
```


```{r, warning=FALSE, message = FALSE}
sol.lsolve <- lsolve.jacobi(mtrx_A, vct_B, xinit = vct_X0, reltol = 1e-05, 
                            maxiter = 10, weight = 1, adjsym = FALSE, verbose = TRUE)

sol.lsolve$x
```

De esta forma verificamos que la implementación es correcta para este ejemplo.


Probamos ahora el método con otra matriz:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(1,0,0,0,
                  0,1,2,1,
                  1,2,0,0,
                  1,1,1,0),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)
```

```{r, echo=FALSE}

funcMetodoJacobi(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones)
```


## Validaciones de Input

Ahora probamos que realice el resto de validaciones necesarias del método Jacobi (adicional a los ceros en diagonal verificadas en el ejemplo anterior).

### Matriz de $n \times n$

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(1,0,0,0,
                  0,1,2,1,
                  1,2,0,0,
                  1,1,1,0,
                  3,1,1,5),
                  nrow=5,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 6, 7)

vct_X0 <- c(0,0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}

funcMetodoJacobi(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones)
```

Ahora colocamos más columnas que filas en la matriz $A$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(1,0,0,0,7,
                  0,1,2,1,0,
                  1,2,0,0,1,
                  1,1,1,0,3),
                  nrow=4,
                  ncol=5,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 6)

vct_X0 <- c(0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}

funcMetodoJacobi(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones)
```


### Tamaño del vector $b$

Vector $b$ con menos elementos que el número de filas de $A$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11)

vct_X0 <- c(0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}
funcMetodoJacobi(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones)
```

Dando ahora un vector $b$ con más elementos que el número de filas de la matriz $A$.

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 4, -8)

vct_X0 <- c(0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}

funcMetodoJacobi(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones)
```

Damos ahora matrices en lugar de vectores en $b$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- matrix(c(1,2,0,7,
                  9,2,6,0,
                  2,5,0,1,
                  1,8,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)


vct_X0 <- c(0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}

funcMetodoJacobi(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones)
```




### Tamaño del vector de aproximación inicial $x_0$

Vector de aproximación inicial $x_0$ con más elementos que el total de filas de $A$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 4)

vct_X0 <- c(0,0,0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}

funcMetodoJacobi(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones)
```

Vector inicial $x_0$ con menos elementos que el total de filas de la matriz $A$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 4)

vct_X0 <- c(0,0,0)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}

funcMetodoJacobi(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones)
```



Damos ahora matrices en lugar de vectores en $x_0$:

```{r, echo=FALSE}
# Matriz A
mtrx_A <- matrix(c(0,0,0,7,
                  1,2,1,0,
                  2,0,0,1,
                  1,1,0,3),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

vct_B <- c(15, 25, -11, 4)

vct_X0 <- matrix(c(0,0,0,0,
                  0,0,0,0,
                  0,0,0,1,
                  0,0,0,0),
                  nrow=4,
                  ncol=4,
                 byrow = TRUE)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)
```

Al ejecutar el algoritmo se obtiene:

```{r, echo=FALSE}

funcMetodoJacobi(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones)
```



# Pruebas con Segunda Versión

En esta versión se incluye el threshold como un criterio de paro del algoritmo.:

```{r, echo=FALSE}

funcEsVectorValido <- function(mtrx, vct){

  # El vector b, debe tener la misma cantidad de filas que la matriz
  bool_VectorValido = FALSE
  if (nrow(mtrx) == length(vct)){
    bool_VectorValido = TRUE
  }

  bool_VectorValido

}

# Valida que sea cuadrada la matriz
funcEsMatrizCuadrada <- function(mtrx){

  # Si el número de filas es igual al número de columnas, es una matriz cuadrada
  if (nrow(mtrx)==ncol(mtrx)){
    bool_Valida <- TRUE
  }
  else{
    bool_Valida <- FALSE
  }

  bool_Valida

}

 # Busca algún cero en la diagonal principal
funcHayCeroEnDiagonal <- function(mtrx){

  bool_HayCero <- FALSE
  nbr_Filas <- nrow(mtrx)
  nbr_Cols <- ncol(mtrx)

  for (i in 1:nbr_Filas){
    for (j in 1:nbr_Cols){
      if ((i==j) && (mtrx[i,j]==0)){
        bool_HayCero <- TRUE
      }
    }
  }

  bool_HayCero

}

# Función que obtiene cada componente del vector
funcObtenerComponente <- function(i, n, mtrx_A, vct_X, vct_B){

  # Variable en la cual acumularemos el resutlado de la sumatoria
  nbr_Sumatoria = 0
  nbr_Final = 0

  # Variables con los términos agrupados de los elementos de la fórmula
  nbr_Termino1 = 0
  nbr_Termino2 = 0

  # Sumatoria de j a n para toda j != i
  for (j in 1:n){
    if (j != i ){

      # Operación de la sumatoria
      nbr_Termino1 = (-(mtrx_A[i,j] * vct_X[j]) / (mtrx_A[i,i]))

      # Acumulamos los valores
      nbr_Sumatoria = nbr_Sumatoria + nbr_Termino1

    }
  }

  # Terminada la sumatoria, se prepara un término extra
  nbr_Termino2 = (vct_B[i] / mtrx_A[i,i])

  # El resultado final, es lo acumulado de la sumatoria más el otro término
  nbr_Final = nbr_Sumatoria + nbr_Termino2

  # Regresamos el resultado
  nbr_Final

}

# Función que obtiene la aproximación de las iteraciones
funcObtenerVctRslt <- function(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo){

  # Inicializamos los vectores de control
  vct_X_Act <- vct_X0
  vct_X_Ant <- vct_X0

  # Los siguientes prints son para debuguear, más adelante se eliminarán
  print(paste0('Iteracion ', 0))
  print(vct_X_Act)

  # Máximo número de iteraciones
  for (it in 1:nbr_MaxIteraciones){

    print(paste0('Iteracion ', it))

    # Iteraciones para obtener cada componente del vector de resultados
    for (i in 1:n){

      # Si se pidió usar el método Jacobi
      if (str_Metodo=='J'){
        vct_X_Act[i]=funcObtenerComponente(i, n, mtrx_A, vct_X_Ant, vct_B)
      }

      # Si se pidió usar el método Gauss-Seidel
      if (str_Metodo=='GS'){
        vct_X_Act[i]=funcObtenerComponente(i, n, mtrx_A, vct_X_Act, vct_B)
      }

    }

    print(vct_X_Act)

    nbr_Numerador <- Norm(vct_X_Act - vct_X_Ant, p = Inf)
    nbr_Denominador <- Norm(vct_X_Act, p = Inf)

    print(paste0('nbr_Numerador: ', nbr_Numerador))
    print(paste0('nbr_Denominador: ', nbr_Denominador))

    nbr_Diff <-  nbr_Numerador / nbr_Denominador
    print(paste0('nbr_Diff: ',nbr_Diff))

    # Si se llega a una diferencia menor al threshold indicado, salimos del for
    if (nbr_Diff<nbr_Threshold){
      print('Se alcanza el threshold')
      break
    }

    # El vector resultado (k), lo usamos como vector anterior (k-1) para la sigueinte
    # iteraación
    vct_X_Ant <- vct_X_Act

  }

  if (it==nbr_MaxIteraciones){
    print('Se llega al tope de iteraciones')
  }

  # Devolvemos el último vector calculado
  vct_X_Act

}

funcInterCambiarFilasVct <- function(vctOrigen, nbr_FilaOrigen, nbr_FilaDestino){

  # Se guarda el valor destino
  nbr_ValorTmp <- vctOrigen[nbr_FilaDestino]

  # Se pone el valor origen hacia el valor destino
  vctOrigen[nbr_FilaDestino] <- vctOrigen[nbr_FilaOrigen]

  # Se recupera el valor destino original, y se pone en valor origen
  vctOrigen[nbr_FilaOrigen] <- nbr_ValorTmp

  # Se regresa el valor
  vctOrigen

}

funcInterCambiarFilasMtrx <- function(mtrx, nbr_FilaOrigen, nbr_FilaDestino, nbr_Cols){

  # Se guarda el valor destino
  vct_FilaTmp <- mtrx[nbr_FilaDestino,1:nbr_Cols]

  # Se pone el valor origen hacia el valor destino
  mtrx[nbr_FilaDestino,1:nbr_Cols] <- mtrx[nbr_FilaOrigen,1:nbr_Cols]

  # Se recupera el valor destino original, y se pone en valor origen
  mtrx[nbr_FilaOrigen,1:nbr_Cols] <- vct_FilaTmp

  # Se regresa el valor
  mtrx

}

funcOrdenarEcuaciones <- function(mtrx_A, vct_B){

  # Variables que se usan dentro de la funcion
  nbr_Filas <- nrow(mtrx_A)
  nbr_Cols <- ncol(mtrx_A)

  # Se barren todas las columnas (iterador j)
  for (j in 1:nbr_Cols){
    # print('Inicia iteracion')

    # Se saca el vector-columna que se usará esta iteración
    vct_Col = mtrx_A[1:nbr_Cols,j]

    # Mostramos el vector-columna con el que trabajaremos
    # print(vct_Col)

    # Se obtiene la norma infinita del vector-columna
    nbr_Norm = Norm(vct_Col, p = Inf)
    # print(nbr_Norm)

    # Se pregunta si el valor es único en el vector-columna
    vct_OrdDesc <- sort(vct_Col, decreasing = TRUE)
    # print(vct_OrdDesc)

    # Si sí es único:
    if (vct_OrdDesc[1] != vct_OrdDesc[2]){
      #print('Es unico')
      # Se obtiene el índice donde está ese valor
      nbr_Index <- match(nbr_Norm,vct_Col)
      # print(nbr_Index)

      # Para realizar el intercambio de filas, nuestra
      # fila origen será: nbr_Index, y la fila destino: j
      mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
      vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

      # print(mtrx_A)

    } else { # Si no es único:
      #print('Hay empate')

      vct_Bool1 <- (vct_Col==nbr_Norm)

      mtrx_Tmp <- mtrx_A[vct_Bool1,1:nbr_Cols]
      #print(mtrx_Tmp)

      # Barremos el resto de las columans para el desempate
      for (jj in (j+1):nbr_Cols){

        vct_ColDesempate <- mtrx_Tmp[,jj]
        # print(paste0('vct_ColDesempate: ', vct_ColDesempate))

        # Buscaremos el valor mínimo de la siguiente columna
        vct_OrdAsc <- sort(vct_ColDesempate)
        # print(vct_OrdAsc)

        # Si el  mínimo es único:
        if (vct_OrdAsc[1] != vct_OrdAsc[2]){

          # print('es unico')
          # Generamos el vector que nos ayudará a obtener las filas a desempatar
          vct_Bool2 <- (vct_ColDesempate == vct_OrdAsc[1])
          # print(vct_Bool2)

          vct_FilaDesempate <- mtrx_Tmp[vct_Bool2]

          # Ya que se tiene la fila mínima del empate, se obtiene su indice
          # en la matriz_A
          vct_Bool3 <- rowSums(mtrx_A == vct_FilaDesempate[col(mtrx_A)]) == ncol(mtrx_A)
          nbr_Index <- match(TRUE,vct_Bool3)

          # Para realizar el intercambio de filas, nuestra
          # fila origen será: nbr_Index, y la fila destino: j
          mtrx_A <- funcInterCambiarFilasMtrx(mtrx_A, nbr_Index, j, nbr_Cols)
          vct_B <- funcInterCambiarFilasVct(vct_B, nbr_Index, j)

          #print(mtrx_A)
          break

        }

      }

    }

  }

  # Regresamos en una lista, la matriz y vector ordenados
  list(matriz=mtrx_A,vector=vct_B)

}

funcResolverSE <- function(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo){

  if (str_Metodo == 'J' || str_Metodo == 'GS'){

    if (str_Metodo=='J'){
      print('Solucion mediante metodo de Jacobi')
    }
    if (str_Metodo=='GS'){
      print('Solucion mediante metodo de Gauss-Sidel')
    }

    print('Matriz A:')
    print(mtrx_A)

    print('Vector b:')
    print(vct_B)

    # Se aplican las validaciones de manera anidada
    if (funcEsVectorValido(mtrx_A, vct_B)){

      if (funcEsVectorValido(mtrx_A, vct_X0)){

        if (funcEsMatrizCuadrada(mtrx_A) == TRUE){

          # Obtenemos la n de la matriz
          n <- nrow(mtrx_A)

          if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

            # Se manda a llamar la función que obtendrá la aproximación
            vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo)

            # Se imprime el resultado
            print('Resultado final: ')
            print(vct_XRslt)

          } else {
            print('La matriz tiene algun cero en la diagonal, comienza ordenamiento')

            lt_Obj <- funcOrdenarEcuaciones(mtrx_A, vct_B)
            mtrx_A <- lt_Obj$matriz
            vct_B <- lt_Obj$vector

            print('Matriz ordenada:')
            print(mtrx_A)

            print('Vector ordenado:')
            print(vct_B)

            if (funcHayCeroEnDiagonal(mtrx_A) == FALSE){

              # Se manda a llamar la función que obtendrá la aproximación
              vct_XRslt <- funcObtenerVctRslt(nbr_MaxIteraciones, n, mtrx_A, vct_B, vct_X0, nbr_Threshold, str_Metodo)

              # Se imprime el resultado
              print('Resultado final: ')
              print(vct_XRslt)

            } else {
              print('Pese al reordenamiento, aun hay ceros en la diagonal')
            }

          }

        } else {
            print('La matriz no cumple con ser de dimensiones nxn')
        }
      } else {
        print('El vector de aproximaciones, debe tener la misma cantidad de filas que la matriz a evaluar')
      }
    } else {
      print('El vector de resultados, debe tener la misma cantidad de filas que la matriz a evaluar')
    }

  }else{
    print('El metodo especificado no es valido, favor de verificar')
  }
}

```


## Prueba con Ejemplo de Clase

Probamos nuevamente el ejemplo de clase, agregando ahora como parámetro el threshold. Declaramos un threshold pequeño para que el algoritmo pare a las 10 iteraciones y de esta forma se pueda comparar con el resultado obtenido en la primera versión:


```{r, echo=FALSE }
mtrx_A <- matrix(c( 0,3,-1,8,
                   -1,11,-1,3,
                    2,-1,10,-1,
                    10,-1,2,0),
                 byrow = TRUE,
                 nrow=4,
                 ncol=4)

vct_B <- c(15, 25, -11, 6)

vct_X0 <- c(0,0,0,0)

nbr_MaxIteraciones <- 10

nbr_Threshold <- 10**(-10)

str_Metodo <- 'J'

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Ejecutamos el método de Jacobi con esta nueva versión:

```{r, echo=TRUE}

funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)

```

Con esta versión se sigue obteniendo un resultado correcto.

Adicional al threshold, se agregó ahora otro parámetro *str_Metodo* que indica cuál método se ejecutará, Jacobi o Gauss-Seidel. Este documento se limita a la revisión del método de Jacobi, en otro documento se realizará la revisión del método Gauss-Seidel.

Ejecutamos el mismo ejemplo, con 100 iteraciones máximo y un threshold de $10^{-5}$

```{r, echo=FALSE }
mtrx_A <- matrix(c( 0,3,-1,8,
                   -1,11,-1,3,
                    2,-1,10,-1,
                    10,-1,2,0),
                 byrow = TRUE,
                 nrow=4,
                 ncol=4)

vct_B <- c(15, 25, -11, 6)

vct_X0 <- c(0,0,0,0)

nbr_MaxIteraciones <- 100

nbr_Threshold <- 10**(-5)

str_Metodo <- 'J'

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

Obteniendo como resultado:

```{r, echo=FALSE}

funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)

```

Se detiene el algoritmo al alcanzar el threshold definido, obteniendo como resultado un vector muy similar al de 10 iteraciones.

Lo comparamos con la función *lsolve.jacobi* con los mismos parámetros:

```{r, echo=FALSE}

mtrx_A <- matrix(c( 10,-1,2,0,
                    -1,11,-1,3,
                    2,-1,10,-1,
                    0,3,-1,8),
                 byrow = TRUE,
                 nrow=4,
                 ncol=4)

vct_B <- c(6, 25, -11, 15)

vct_X0 <- c(0,0,0,0)
```


```{r, echo=TRUE, message=FALSE}

sol.lsolve <- lsolve.jacobi(mtrx_A, vct_B, xinit = vct_X0, reltol = 1e-05, 
                            maxiter = 100, weight = 1, adjsym = FALSE, verbose = TRUE)
sol.lsolve$x

```

Donde observamos que los resultados coinciden en aproximadamente 5 decimales, de hecho coincide el resultado de *lsolve.jacobi* con la iteración 14 de nuestro método, donde el cociente $\frac{||x^{(k)}-x^{(k-1)}||_\infty}{||x^{(k)}||_\infty}$ es igual a $1.33731330418549\times 10^{-5}$.


## Matrices Dominantes Estrictas en la Diagonal por Renglones

Una [matriz dominante estricta en la diagonal por renglones](https://github.com/ITAM-DS/analisis-numerico-computo-cientifico/blob/master/temas/III.computo_matricial/3.3.e.Jacobi_Gauss-Seidel.ipynb) es aquélla que cumple:

$\mid a_{ij} \mid \gt \sum_{\overset{j=1}{j\neq i}}^n \mid a_{ij} \mid$ para toda $i$, donde $a_{ij}$ es el elemento del renglón $i$ y columna $j$ de $A$.


Realizaremos pruebas con estas matrices, pues como se menciona en [la nota de clase](https://github.com/ITAM-DS/analisis-numerico-computo-cientifico/blob/master/temas/III.computo_matricial/3.3.e.Jacobi_Gauss-Seidel.ipynb), existe un teorema que garantiza la convergencia del método Jacobi si la matriz A es dominante estricta en la diagonal por renglones.

Probamos con el ejemplo más sencillo de estas matrices, donde $A$ es la matriz identidad:

```{r, echo=F}

mtrx_A <- diag(10)


vct_B <- c(-12,
           -8,
           9,
           -17,
           19,
           20,
           19,
           19,
           29,
           -5)


vct_X0 <- c(0,0,0,0,0,0,0,0,0,0)

nbr_MaxIteraciones <- 100

nbr_Threshold <- 10**(-5)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)

```

Obteniendo como resultado el vector $b$:

```{r, echo_FALSE}

funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)


```

Probamos ahora una matriz de $10 \times 10$ estrictamente diagonal positiva diferente a la identidad:

```{r, echo=F}

mtrx_A <- matrix(c( 300,19,15,-20,-29,29,-15,-28,-9,-6,
                    -1,-150,-14,0,-7,14,11,-6,6,10,
                    13,3,-310,9,-8,7,-6,8,20,-22,
                    3,-2,-15,260,2,-12,18,-10,-17,25,
                    -23,-29,6,9,320,-4,4,-13,13,8,
                    -4,15,9,12,21,220,-14,1,18,-1,
                    11,-11,8,28,13,27,-330,18,24,13,
                    17,-17,-10,-7,11,22,21,240,12,-21,
                    9,-22,-9,-16,4,-20,28,16,300,17,
                    16,20,13,15,-26,8,24,5,-27,280),
                 byrow = TRUE,
                 nrow=10,
                 ncol=10)

vct_B <- c(-12,
           -8,
           9,
           -17,
           19,
           20,
           19,
           19,
           29,
           -5)


vct_X0 <- c(0,0,0,0,0,0,0,0,0,0)

nbr_MaxIteraciones <- 100

nbr_Threshold <- 10**(-5)

print('Matriz A:')
print(mtrx_A)

print('Vector b:')
print(vct_B)

print('Punto inicial:')
print(vct_X0)

print('Máximo número de iteraciones:')
print(nbr_MaxIteraciones)

print('Threshold:')
print(nbr_Threshold)
```

El algoritmo devuelve:

```{r}
funcResolverSE(mtrx_A, vct_B, vct_X0, nbr_MaxIteraciones, nbr_Threshold, str_Metodo)


```

Se detiene en la iteración 8 al llegar al threshold, pues el método converge.

La función *lsolve.jacobi* devuelve un resultado muy similar, con aproximadamente 6 decimales iguales al resultado de nuestro algoritmo:

```{r, echo=F, message=F}

sol.lsolve <- lsolve.jacobi(mtrx_A, vct_B, xinit = vct_X0, reltol = 1e-05, 
                            maxiter = 100, weight = 1, adjsym = FALSE, verbose = TRUE)

```


```{r, echo=T, message=F}

sol.lsolve$x
sol.lsolve$iter

```

